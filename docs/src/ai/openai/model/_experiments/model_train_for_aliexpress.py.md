# Модуль `model_train_for_aliexpress.py`

## Обзор

Модуль предназначен для экспериментов с AI-моделями OpenAI и Google Gemini для обработки данных, связанных с AliExpress кампаниями. Он загружает заголовки продуктов из файлов, расположенных в Google Drive, и использует AI-модели для анализа этих данных.

## Подробней

Этот модуль является экспериментальной частью проекта, предназначенной для обучения и тестирования AI-моделей на данных AliExpress. Он включает в себя чтение данных из файлов, использование моделей OpenAI и Google Gemini для генерации ответов на основе этих данных.

## Функции

### `read_text_file`

```python
def read_text_file(file_path: str | Path,
    as_list: bool = False,
    extensions: Optional[List[str]] = None,
    chunk_size: int = 8192,) -> Generator[str, None, None] | str | None:
    """
    Считывает содержимое файла (или файлов из каталога) с использованием генератора для экономии памяти.

    Args:
        file_path (str | Path): Путь к файлу или каталогу.
        as_list (bool): Если `True`, возвращает генератор строк.
        extensions (Optional[List[str]]): Список расширений файлов для чтения из каталога.
        chunk_size (int): Размер чанков для чтения файла в байтах.

    Returns:
        Generator[str, None, None] | str | None: Генератор строк, объединенная строка или `None` в случае ошибки.

    Raises:
        Exception: Если возникает ошибка при чтении файла.

    Example:
        >>> from pathlib import Path
        >>> file_path = Path('example.txt')
        >>> content = read_text_file(file_path)
        >>> if content:
        ...    print(f'File content: {content[:100]}...')
        File content: Example text...
    """
    ...
```

**Назначение**: Считывает содержимое текстового файла или нескольких файлов из указанного каталога.

**Параметры**:

-   `file_path` (str | Path): Путь к файлу или каталогу.
-   `as_list` (bool, optional): Если `True`, содержимое возвращается в виде списка строк. По умолчанию `False`.
-   `extensions` (Optional[List[str]], optional): Список расширений файлов для чтения из каталога. По умолчанию `None`.
-   `chunk_size` (int, optional): Размер чанков для чтения файла в байтах. По умолчанию `8192`.

**Возвращает**:

-   `Generator[str, None, None] | str | None`: Генератор строк, если `as_list` равен `True`. Одна строка, если `as_list` равен `False`. `None` в случае ошибки.

**Вызывает исключения**:

-   `Exception`: Если возникает ошибка при чтении файла.

**Как работает функция**:

1.  Функция определяет, является ли `file_path` файлом или каталогом.
2.  Если `file_path` - это файл, он открывается, и содержимое считывается. Если `as_list` равно `True`, содержимое возвращается в виде списка строк, иначе - как одна строка.
3.  Если `file_path` - это каталог, функция рекурсивно получает список файлов с указанными расширениями. Затем содержимое каждого файла считывается и объединяется в одну строку, которая возвращается.
4.  В случае возникновения ошибки при чтении файла, функция возвращает `None`.

**Внутренние функции**: Нет

**Примеры**:

```python
from pathlib import Path
file_path = Path('example.txt')
content = read_text_file(file_path)
if content:
   print(f'File content: {content[:100]}...')
```

### `recursively_get_filenames`

```python
def recursively_get_filenames(dir_path: str | Path, file_extension: str) -> list:
    """
    Рекурсивно получает список файлов с указанным расширением из заданного каталога и всех его подкаталогов.

    Args:
        dir_path (str | Path): Путь к каталогу.
        file_extension (str): Расширение файлов для поиска.

    Returns:
        list: Список путей к файлам с указанным расширением.

    Raises:
        FileNotFoundError: Если указанный путь не является каталогом.

    Example:
        >>> from pathlib import Path
        >>> dir_path = Path('.')
        >>> file_extension = '.txt'
        >>> file_list = recursively_get_filenames(dir_path, file_extension)
        >>> print(file_list)
        [WindowsPath('file1.txt'), WindowsPath('folder/file2.txt')]
    """
    ...
```

**Назначение**: Рекурсивно получает список файлов с указанным расширением из заданного каталога и всех его подкаталогов.

**Параметры**:

-   `dir_path` (str | Path): Путь к каталогу.
-   `file_extension` (str): Расширение файлов для поиска.

**Возвращает**:

-   `list`: Список путей к файлам с указанным расширением.

**Вызывает исключения**:

-   `FileNotFoundError`: Если указанный путь не является каталогом.

**Как работает функция**:

1.  Функция проверяет, является ли `dir_path` каталогом. Если нет, вызывается исключение `FileNotFoundError`.
2.  Затем функция обходит все файлы и подкаталоги в `dir_path` рекурсивно.
3.  Для каждого файла проверяется, соответствует ли его расширение заданному `file_extension`.
4.  Если расширение совпадает, путь к файлу добавляется в список результатов.
5.  В конце функция возвращает список всех найденных файлов.

**Внутренние функции**: Нет

**Примеры**:

```python
from pathlib import Path
dir_path = Path('.')
file_extension = '.txt'
file_list = recursively_get_filenames(dir_path, file_extension)
print(file_list)
```

### `csv2json_csv2dict`

```python
def csv2json_csv2dict(file_path: str, delimiter: str = ",") -> list[dict]:
    """Преобразует CSV-файл в список словарей (JSON).

    Args:
        file_path (str): Путь к CSV-файлу.
        delimiter (str, optional): Разделитель столбцов в CSV-файле. По умолчанию ",".

    Returns:
        list[dict]: Список словарей, где каждый словарь представляет строку из CSV-файла.
    
    Raises:
        FileNotFoundError: Если указанный файл не существует.
        ValueError: Если возникают проблемы при чтении или преобразовании CSV-файла.

    Example:
        >>> data = csv2json_csv2dict('data.csv', delimiter=';')
        >>> print(data)
        [{'col1': 'value1', 'col2': 'value2'}, {'col1': 'value3', 'col2': 'value4'}]
    """
    ...
```

**Назначение**: Преобразует CSV-файл в список словарей (JSON).

**Параметры**:

-   `file_path` (str): Путь к CSV-файлу.
-   `delimiter` (str, optional): Разделитель столбцов в CSV-файле. По умолчанию ",".

**Возвращает**:

-   `list[dict]`: Список словарей, где каждый словарь представляет строку из CSV-файла.

**Вызывает исключения**:

-   `FileNotFoundError`: Если указанный файл не существует.
-   `ValueError`: Если возникают проблемы при чтении или преобразовании CSV-файла.

**Как работает функция**:

1.  Открывает CSV-файл по указанному пути.
2.  Использует модуль `csv` для чтения данных из файла, разделяя столбцы по указанному разделителю.
3.  Первая строка CSV-файла интерпретируется как заголовки столбцов.
4.  Для каждой последующей строки создается словарь, где ключами являются заголовки столбцов, а значениями - соответствующие значения из строки.
5.  Все созданные словари добавляются в список, который возвращается в результате.

**Внутренние функции**: Нет

**Примеры**:

```python
data = csv2json_csv2dict('data.csv', delimiter=';')
print(data)
```

## Переменные

-   `product_titles_files` (list): Список файлов, содержащих заголовки продуктов, полученных рекурсивно из каталога `aliexpress/campaigns` в Google Drive.
-   `system_instruction_path` (Path): Путь к файлу `system_instruction.txt`, содержащему системные инструкции для AI-моделей.
-   `system_instruction` (str): Содержимое файла `system_instruction.txt`, прочитанное как строка.
-   `openai` (OpenAIModel): Экземпляр класса `OpenAIModel`, инициализированный с системными инструкциями.
-   `gemini` (GoogleGenerativeAI): Экземпляр класса `GoogleGenerativeAI`, инициализированный с системными инструкциями.

## Цикл обработки файлов

В основном цикле кода происходит следующее:

1.  Перебираются все файлы в списке `product_titles_files`.
2.  Для каждого файла считываются заголовки продуктов.
3.  Заголовки продуктов отправляются в модели OpenAI и Gemini для получения ответов.
4.  <инструкция для модели gemini:Сохранение результатов обработки данных, полученных от моделей OpenAI и Gemini.>

```
A: Получение списка файлов с заголовками продуктов
|
B: Перебор файлов в списке
|
C: Чтение заголовков продуктов из файла
|
D: Отправка заголовков продуктов в OpenAI модель
|
E: Отправка заголовков продуктов в Gemini модель
|
F: <инструкция для модели gemini:Сохранение результатов обработки данных, полученных от моделей OpenAI и Gemini.>