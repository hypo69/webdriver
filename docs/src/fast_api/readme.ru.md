# Документация для разработчика: `fast_api_rpc.py` и `main.py`

## Обзор

Этот документ предоставляет подробное описание работы модулей `fast_api_rpc.py` и `main.py`, которые образуют клиент-серверную систему управления FastAPI сервером.  В `fast_api_rpc.py` реализована серверная часть, управляющая запуском и остановкой FastAPI серверов, а также добавлением новых маршрутов. `main.py` представляет собой клиентскую часть, предоставляющую пользовательский интерфейс для взаимодействия с сервером посредством XML-RPC.

## Подробнее

Данный код реализует механизм удаленного управления FastAPI сервером(ами) с использованием XML-RPC.  `fast_api_rpc.py` содержит класс `CommandHandler`, который предоставляет методы управления сервером (запуск, остановка, добавление маршрутов и т.д.), доступные через XML-RPC. `main.py` предоставляет консольный интерфейс, позволяющий пользователю отправлять команды на сервер и контролировать его работу.

## Основные компоненты

### `fast_api_rpc.py` (серверная часть)

*   **`FastApiServer`**: Класс, содержащий логику для запуска FastAPI-сервера. Он отвечает за создание и настройку веб-сервера, а также за добавление новых маршрутов.
*   **`CommandHandler`**:
    *   Это класс, который управляет вызовами функций управления сервером.
    *   Он содержит методы, такие как `start_server`, `stop_server`, `stop_all_servers`, `status_servers`, `add_new_route` и `shutdown`, которые могут вызываться удаленно через XML-RPC.
    *   Внутри конструктора `__init__` создается объект `SimpleXMLRPCServer`, который слушает запросы на порту `9000` (по умолчанию).
    *   Метод `register_instance(self)` позволяет сделать все методы этого класса доступными для удаленного вызова.
    *   `threading.Thread(target=self.rpc_server.serve_forever, daemon=True).start()` запускает XML-RPC сервер в отдельном потоке, что позволяет ему работать параллельно с остальным кодом.

### `main.py` (клиентская часть)

*   **`ServerProxy`**: Этот класс из библиотеки `xmlrpc.client` используется для создания объекта, через который можно вызывать методы XML-RPC сервера. `rpc_client = ServerProxy("http://localhost:9000", allow_none=True)` устанавливает соединение с сервером.
*   **Цикл `while True`**:
    *   Отображает меню доступных команд.
    *   Запрашивает ввод пользователя.
    *   Парсит введенную строку, выделяя команду и её аргументы.
    *   В зависимости от введенной команды вызывает соответствующий метод RPC-сервера через объект `rpc_client`.

## Взаимодействие между компонентами

1.  **Запуск `fast_api_rpc.py`**: Когда запускается `fast_api_rpc.py`, происходит следующее:
    *   Создается экземпляр `CommandHandler`.
    *   В конструкторе `CommandHandler` создается XML-RPC сервер, который начинает слушать порт `9000`.
    *   Запускается FastAPI-сервер(ы) в соответствии с кодом, который мы создали.
2.  **Запуск `main.py`**: Когда запускается `main.py`, происходит следующее:
    *   Создается экземпляр `CommandHandler` (но он не играет роли, поскольку в `main.py` используется только RPC-клиент).
    *   Создается `ServerProxy`, который подключается к XML-RPC серверу по адресу `http://localhost:9000`.
    *   `main.py` начинает показывать меню и ожидать ввода пользователя.
3.  **Ввод команды**: Когда пользователь вводит команду в `main.py`, например `start 8000`:
    *   `main.py` анализирует эту строку, выделяет команду `start` и порт `8000`.
    *   `main.py` вызывает метод `start_server(port=8000, host="0.0.0.0")` у объекта `rpc_client`. Это *не* вызов метода на локальном объекте, а запрос к XML-RPC серверу.
4.  **Обработка запроса на сервере**: XML-RPC клиент `rpc_client` создает XML-сообщение, которое отправляет на сервер `fast_api_rpc.py`.
    *   XML-RPC сервер в `fast_api_rpc.py` получает этот запрос.
    *   Он понимает, что нужно вызвать метод `start_server` у объекта `CommandHandler`.
    *   Вызывается метод `start_server`, который вызывает функцию `start_server` и запускает FastAPI сервер.
5.  **Возврат ответа**: XML-RPC сервер формирует ответ, содержащий результат вызова (в данном случае, это может быть `None`).
    *   Этот ответ отправляется обратно клиенту `main.py`.
    *   Клиент получает ответ.
6.  **Отображение результата**: `main.py` может отобразить результат в консоль (или проигнорировать его, если это None).
7.  **Повторение цикла**: `main.py` возвращается к началу цикла, отображая меню и ожидая ввода следующей команды.

## Преимущества подхода

*   **Управление сервером из другой программы**: Можно контролировать запущенный сервер через другой процесс или даже с другой машины.
*   **Разделение кода**: Логика управления сервером и пользовательский интерфейс разделены, что делает код более модульным и легким в обслуживании.
*   **Гибкость**: Можно добавить новые методы управления сервером, просто добавив их в `CommandHandler`, и они автоматически станут доступны через RPC.