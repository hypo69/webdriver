# Модуль для работы с JSON и SimpleNamespace

## Обзор

Модуль `jjson` предназначен для упрощения работы с данными в формате JSON, включая чтение, запись и преобразование в объекты `SimpleNamespace`. Он предоставляет функции для загрузки JSON из различных источников (файлы, строки, объекты), сохранения JSON в файлы, а также для обработки и преобразования данных. Модуль также включает поддержку обработки ошибок и ведения журнала операций через `logger`.

## Подробней

Этот модуль предоставляет удобные инструменты для работы с JSON-данными, позволяя легко загружать, сохранять и преобразовывать данные в различные форматы. Он также обеспечивает обработку ошибок и журналирование для облегчения отладки и мониторинга.

## Классы

### `Config`

**Описание**: Класс `Config` содержит статические переменные, определяющие режимы открытия файлов для записи и добавления данных.

**Атрибуты**:
- `MODE_WRITE` (str): Режим открытия файла для записи (`"w"`).
- `MODE_APPEND_START` (str): Режим открытия файла для добавления данных в начало (`"a+"`).
- `MODE_APPEND_END` (str): Режим открытия файла для добавления данных в конец (`"+a"`).

## Функции

### `_convert_to_dict`

```python
def _convert_to_dict(value: Any) -> Any:
    """ Функция преобразует объекты SimpleNamespace и списки в словари.

    Args:
        value (Any): Объект для преобразования.

    Returns:
        Any: Преобразованный объект в виде словаря, списка или другого типа данных.
    """
```

**Назначение**: Функция рекурсивно преобразует объекты `SimpleNamespace` и списки в словари. Это необходимо для работы с данными, представленными в виде объектов, которые нужно сериализовать в JSON.

**Параметры**:
- `value` (Any): Значение, которое нужно преобразовать. Может быть экземпляром `SimpleNamespace`, словарем, списком или другим типом данных.

**Возвращает**:
- `Any`: Преобразованное значение. Если входное значение является `SimpleNamespace` или словарем, функция вернет словарь. Если входное значение является списком, функция вернет список, содержащий преобразованные элементы. В противном случае функция вернет входное значение без изменений.

**Как работает функция**:
1. **Проверка типа**: Функция проверяет тип входного значения `value`.
2. **Преобразование SimpleNamespace**: Если `value` является экземпляром `SimpleNamespace`, функция преобразует его в словарь, рекурсивно применяя `_convert_to_dict` к каждому значению атрибута.
3. **Преобразование словаря**: Если `value` является словарем, функция создает новый словарь, рекурсивно применяя `_convert_to_dict` к каждому значению.
4. **Преобразование списка**: Если `value` является списком, функция создает новый список, рекурсивно применяя `_convert_to_dict` к каждому элементу.
5. **Возврат значения**: Если `value` не является ни `SimpleNamespace`, ни словарем, ни списком, функция возвращает его без изменений.

**Примеры**:
```python
from types import SimpleNamespace

data = SimpleNamespace(name='John', age=30, address=SimpleNamespace(city='New York'))
result = _convert_to_dict(data)
print(result)  # Вывод: {'name': 'John', 'age': 30, 'address': {'city': 'New York'}}
```

```
A (value)
│
├───SimpleNamespace?─── Да: Преобразовать в словарь (рекурсивно)
│   │
│   └───Словарь?─── Да: Преобразовать значения (рекурсивно)
│       │
│       └───Список?─── Да: Преобразовать элементы (рекурсивно)
│           │
│           └───Нет: Вернуть значение
│
└───Нет: Вернуть значение
```

### `_read_existing_data`

```python
def _read_existing_data(path: Path, exc_info: bool = True) -> dict:
    """Считывает существующие JSON-данные из файла.

    Args:
        path (Path): Путь к файлу.
        exc_info (bool): Флаг, определяющий, следует ли логировать исключения с трассировкой.

    Returns:
        dict: Словарь с данными из файла или пустой словарь в случае ошибки.
    """
```

**Назначение**: Функция считывает существующие JSON-данные из файла, обрабатывая возможные ошибки при чтении и декодировании JSON.

**Параметры**:
- `path` (Path): Путь к файлу, из которого нужно считать JSON-данные.
- `exc_info` (bool, optional): Флаг, определяющий, следует ли логировать исключения с трассировкой. По умолчанию `True`.

**Возвращает**:
- `dict`: Словарь с данными из файла. В случае возникновения ошибок возвращает пустой словарь `{}`.

**Вызывает исключения**:
- `json.JSONDecodeError`: Если JSON-данные в файле недействительны.
- `Exception`: При возникновении других ошибок чтения файла.

**Как работает функция**:
1. **Чтение данных из файла**: Функция пытается прочитать содержимое файла, используя метод `path.read_text(encoding="utf-8")`.
2. **Декодирование JSON**: Если чтение файла прошло успешно, функция пытается декодировать JSON-данные, используя `json.loads()`.
3. **Обработка ошибок JSON**: Если при декодировании JSON возникает ошибка `json.JSONDecodeError`, функция логирует ошибку с использованием `logger.error()` и возвращает пустой словарь.
4. **Обработка общих ошибок**: Если возникает любая другая ошибка, функция логирует ошибку и возвращает пустой словарь.
5. **Возврат данных**: Если чтение и декодирование прошли успешно, функция возвращает словарь с данными.

**Примеры**:
```python
from pathlib import Path

# Пример чтения данных из существующего файла
file_path = Path("config.json")
if file_path.exists():
    data = _read_existing_data(file_path)
    print(data)
else:
    print(f"Файл {file_path} не существует.")
```

```
A (path)
│
├───Чтение файла───Чтение текста из файла
│
├───Декодирование JSON───Попытка преобразования текста в JSON
│   │
│   └───Ошибка JSON?─── Да: Логирование ошибки, возврат {}
│       │
│       └───Общая ошибка?─── Да: Логирование ошибки, возврат {}
│           │
│           └───Нет: Возврат данных
│
└───Нет: Возврат {}
```

### `_merge_data`

```python
def _merge_data(
    data: Dict, existing_data: Dict, mode: str
) -> Dict:
    """Объединяет новые данные с существующими данными в зависимости от режима.

    Args:
        data (Dict): Новые данные для объединения.
        existing_data (Dict): Существующие данные.
        mode (str): Режим объединения (Config.MODE_APPEND_START или Config.MODE_APPEND_END).

    Returns:
        Dict: Объединенные данные.
    """
```

**Назначение**: Функция объединяет новые данные с существующими данными в зависимости от указанного режима (`mode`). Поддерживает объединение списков и словарей.

**Параметры**:
- `data` (Dict): Новые данные, которые нужно объединить с существующими данными.
- `existing_data` (Dict): Существующие данные, с которыми нужно объединить новые данные.
- `mode` (str): Режим объединения. Может быть `Config.MODE_APPEND_START` (добавить новые данные в начало) или `Config.MODE_APPEND_END` (добавить новые данные в конец).

**Возвращает**:
- `Dict`: Объединенные данные в виде словаря или списка. В случае ошибки возвращает пустой словарь `{}`.

**Как работает функция**:
1. **Проверка режима**: Функция проверяет значение параметра `mode`.
2. **Режим `MODE_APPEND_START`**: Если `mode` равен `Config.MODE_APPEND_START`, функция проверяет типы `data` и `existing_data`.
   - Если оба являются списками, функция объединяет `data` и `existing_data`, добавляя `data` в начало `existing_data`.
   - Если оба являются словарями, функция обновляет `existing_data` данными из `data`.
   - Возвращает `existing_data`.
3. **Режим `MODE_APPEND_END`**: Если `mode` равен `Config.MODE_APPEND_END`, функция проверяет типы `data` и `existing_data`.
   - Если оба являются списками, функция объединяет `existing_data` и `data`, добавляя `data` в конец `existing_data`.
   - Если оба являются словарями, функция обновляет `data` данными из `existing_data`.
   - Возвращает `data`.
4. **Режим по умолчанию**: Если `mode` не соответствует ни одному из поддерживаемых значений, функция возвращает `data` без изменений.
5. **Обработка исключений**: Если в процессе объединения данных возникает исключение, функция логирует ошибку и возвращает пустой словарь.

**Примеры**:
```python
data = {'new_key': 'new_value'}
existing_data = {'existing_key': 'existing_value'}
mode = Config.MODE_APPEND_END
result = _merge_data(data, existing_data, mode)
print(result)  # Вывод: {'new_key': 'new_value', 'existing_key': 'existing_value'}
```

```
A (data, existing_data, mode)
│
├───Проверка режима───MODE_APPEND_START?
│   │
│   ├───Да───Оба списка?
│   │   │
│   │   ├───Да───data + existing_data
│   │   │
│   │   └───Оба словаря?
│   │       │
│   │       ├───Да───existing_data.update(data)
│   │       │
│   │       └───Возврат existing_data
│   │
│   └───MODE_APPEND_END?
│       │
│       ├───Да───Оба списка?
│       │   │
│       │   ├───Да───existing_data + data
│       │   │
│       │   └───Оба словаря?
│       │       │
│       │       ├───Да───data.update(existing_data)
│       │       │
│       │       └───Возврат data
│       │
│       └───Нет───Возврат data
│
└───Обработка ошибок───Логирование ошибки, возврат {}
```

### `j_dumps`

```python
def j_dumps(
    data: Union[Dict, SimpleNamespace, List[Dict], List[SimpleNamespace]],
    file_path: Optional[Path] = None,
    ensure_ascii: bool = False,
    mode: str = Config.MODE_WRITE,
    exc_info: bool = True,
) -> Optional[Dict]:
    """
    Сохраняет JSON-данные в файл или возвращает JSON-данные в виде словаря.

    Args:
        data (Dict | SimpleNamespace | List[Dict] | List[SimpleNamespace]): JSON-совместимые данные или объекты SimpleNamespace для сохранения.
        file_path (Optional[Path], optional): Путь к выходному файлу. Если None, возвращает JSON в виде словаря. По умолчанию None.
        ensure_ascii (bool, optional): Если True, экранирует не-ASCII символы в выводе. По умолчанию True.
        mode (str, optional): Режим открытия файла ('w', 'a+', '+a'). По умолчанию 'w'.
        exc_info (bool, optional): Если True, логирует исключения с трассировкой. По умолчанию True.

    Returns:
        Optional[Dict]: JSON-данные в виде словаря в случае успеха или None в случае ошибки.

    Raises:
        ValueError: Если режим файла не поддерживается.
    """
```

**Назначение**: Функция `j_dumps` преобразует данные в формат JSON и сохраняет их в файл или возвращает в виде словаря. Поддерживает различные режимы записи, такие как перезапись, добавление в начало и добавление в конец файла.

**Параметры**:
- `data` (Dict | SimpleNamespace | List[Dict] | List[SimpleNamespace]): Данные для сохранения в формате JSON. Поддерживаются словари, объекты `SimpleNamespace` и списки словарей или объектов `SimpleNamespace`.
- `file_path` (Optional[Path], optional): Путь к файлу, в который нужно сохранить данные. Если `None`, функция возвращает данные в виде словаря. По умолчанию `None`.
- `ensure_ascii` (bool, optional): Если `True`, функция экранирует не-ASCII символы. По умолчанию `False`.
- `mode` (str, optional): Режим открытия файла. Может быть `'w'` (перезапись), `'a+'` (добавление в начало) или `'+a'` (добавление в конец). По умолчанию `'w'`.
- `exc_info` (bool, optional): Если `True`, функция логирует исключения с трассировкой. По умолчанию `True`.

**Возвращает**:
- `Optional[Dict]`: В случае успеха функция возвращает JSON-данные в виде словаря. Если `file_path` не указан, функция возвращает преобразованные данные. В случае ошибки функция возвращает `None`.

**Вызывает исключения**:
- `ValueError`: Если указан неподдерживаемый режим файла.

**Как работает функция**:
1. **Преобразование данных**: Функция преобразует входные данные в словарь, используя функцию `_convert_to_dict`.
2. **Обработка строковых данных**: Если входные данные являются строкой, функция пытается исправить JSON-структуру с помощью `repair_json`.
3. **Выбор режима записи**: Если указанный режим записи не поддерживается, устанавливается режим по умолчанию `'w'`.
4. **Чтение существующих данных**: Если указан путь к файлу и режим записи — добавление, функция пытается прочитать существующие данные из файла с помощью функции `_read_existing_data`.
5. **Объединение данных**: Функция объединяет новые данные с существующими данными, используя функцию `_merge_data` и указанный режим записи.
6. **Запись в файл или возврат данных**: Если указан путь к файлу, функция пытается записать данные в файл, используя `json.dump`. Если путь не указан, функция возвращает данные в виде словаря.
7. **Обработка ошибок**: Если в процессе записи или преобразования данных возникает ошибка, функция логирует ошибку и возвращает `None`.

**Примеры**:
```python
data = {'name': 'John', 'age': 30}
file_path = 'data.json'
result = j_dumps(data, file_path=file_path)
print(result)  # Вывод: {'name': 'John', 'age': 30}

data = {'name': 'Иван', 'age': 30}
file_path = 'data.json'
result = j_dumps(data, file_path=file_path, ensure_ascii=False)
print(result)  # Вывод: {'name': 'Иван', 'age': 30}
```

```
A (data, file_path, ensure_ascii, mode, exc_info)
│
├───Преобразование данных───Преобразование в словарь (_convert_to_dict)
│
├───Строка?───Да: Попытка исправления JSON (repair_json)
│
├───Выбор режима записи───Режим не поддерживается?
│   │
│   └───Да: Установка режима по умолчанию ('w')
│
├───Чтение существующих данных───file_path указан и режим - добавление?
│   │
│   └───Да: Чтение существующих данных (_read_existing_data)
│
├───Объединение данных───Объединение с существующими данными (_merge_data)
│
├───Запись в файл или возврат───file_path указан?
│   │
│   ├───Да: Запись в файл (json.dump)
│   │
│   └───Нет: Возврат данных
│
└───Обработка ошибок───Логирование ошибки, возврат None
```

### `_decode_strings`

```python
def _decode_strings(data: Any) -> Any:
    """Рекурсивно декодирует строки в структуре данных."""
```

**Назначение**: Функция рекурсивно декодирует строки в структуре данных, используя кодировку `unicode_escape`. Это полезно для обработки строк, содержащих экранированные символы Unicode.

**Параметры**:
- `data` (Any): Структура данных, в которой нужно декодировать строки. Может быть строкой, списком или словарем.

**Возвращает**:
- `Any`: Структура данных с декодированными строками.

**Как работает функция**:
1. **Проверка типа данных**: Функция проверяет тип входных данных `data`.
2. **Декодирование строки**: Если `data` является строкой, функция пытается декодировать ее, используя `codecs.decode(data, 'unicode_escape')`. Если декодирование не удается, возвращается исходная строка.
3. **Декодирование списка**: Если `data` является списком, функция рекурсивно применяет `_decode_strings` к каждому элементу списка и возвращает новый список с декодированными элементами.
4. **Декодирование словаря**: Если `data` является словарем, функция рекурсивно применяет `_decode_strings` к каждому ключу и значению словаря и возвращает новый словарь с декодированными ключами и значениями.
5. **Возврат данных без изменений**: Если `data` не является строкой, списком или словарем, функция возвращает `data` без изменений.

**Примеры**:
```python
data = "Пример строки с \\u0441\\u0438\\u043c\\u0432\\u043e\\u043b\\u0430\\u043c\\u0438 Unicode"
result = _decode_strings(data)
print(result)  # Вывод: Пример строки с символами Unicode
```

```
A (data)
│
├───Строка?───Да: Декодирование строки (codecs.decode)
│   │
│   └───Список?───Да: Рекурсивное декодирование элементов списка
│       │
│       └───Словарь?───Да: Рекурсивное декодирование ключей и значений словаря
│           │
│           └───Нет: Возврат данных без изменений
│
└───Нет: Возврат данных без изменений
```

### `_string_to_dict`

```python
def _string_to_dict(json_string: str) -> dict:
    """Удаляет markdown кавычки и преобразует JSON строку в словарь."""
```

**Назначение**: Функция `_string_to_dict` принимает строку, которая может содержать JSON-данные, и преобразует её в словарь Python. Функция также удаляет markdown-кавычки, если они присутствуют.

**Параметры**:
- `json_string` (str): Строка, содержащая JSON-данные.

**Возвращает**:
- `dict`: Словарь, полученный из JSON-строки. Возвращает пустой словарь `{}` в случае ошибки.

**Как работает функция**:
1. **Удаление markdown-кавычек**: Если строка начинается с ` ``` ` или ` ```json ` и заканчивается на ` ``` ` или ` ```\n `, функция удаляет эти кавычки и удаляет слово `json`.
2. **Преобразование в словарь**: Функция пытается преобразовать строку в словарь, используя `json.loads()`.
3. **Обработка ошибок**: Если при преобразовании возникает ошибка `json.JSONDecodeError`, функция логирует ошибку и возвращает пустой словарь.

**Примеры**:
```python
json_string = "```json\n{\"name\": \"John\", \"age\": 30}\n```"
result = _string_to_dict(json_string)
print(result)  # Вывод: {'name': 'John', 'age': 30}
```

```
A (json_string)
│
├───Удаление markdown-кавычек───Проверка наличия и удаление кавычек
│
├───Преобразование в словарь───Преобразование строки в словарь (json.loads)
│   │
│   └───Ошибка?───Да: Логирование ошибки, возврат {}
│       │
│       └───Нет: Возврат словаря
│
└───Нет: Возврат {}
```

### `j_loads`

```python
def j_loads(
    jjson: Union[dict, SimpleNamespace, str, Path, list], ordered: bool = True
) -> Union[dict, list]:
    """
    Загружает JSON или CSV данные из файла, каталога, строки или объекта.

    Args:
        jjson (dict | SimpleNamespace | str | Path | list): Путь к файлу/каталогу, JSON строка или JSON объект.
        ordered (bool, optional): Использовать OrderedDict для сохранения порядка элементов. По умолчанию True.

    Returns:
        dict | list: Обработанные данные (словарь или список словарей).

    Raises:
        FileNotFoundError: Если указанный файл не найден.
        json.JSONDecodeError: Если JSON данные не могут быть распарсены.
    """
```

**Назначение**: Функция `j_loads` загружает JSON-данные из различных источников, таких как файлы, каталоги, строки или объекты, и возвращает их в виде словаря или списка.

**Параметры**:
- `jjson` (dict | SimpleNamespace | str | Path | list): Путь к файлу/каталогу, JSON-строка или JSON-объект.
- `ordered` (bool, optional): Использовать `OrderedDict` для сохранения порядка элементов. По умолчанию `True`.

**Возвращает**:
- `dict | list`: Обработанные данные в виде словаря или списка словарей.

**Вызывает исключения**:
- `FileNotFoundError`: Если указанный файл не найден.
- `json.JSONDecodeError`: Если JSON-данные не могут быть распарсены.

**Как работает функция**:
1. **Обработка `SimpleNamespace`**: Если `jjson` является экземпляром `SimpleNamespace`, он преобразуется в словарь с помощью `vars(jjson)`.
2. **Обработка `Path`**: Если `jjson` является экземпляром `Path`:
   - Если это директория, функция рекурсивно вызывает `j_loads` для каждого файла `*.json` в этой директории.
   - Если это файл, функция считывает его содержимое и преобразует его в JSON.
3. **Обработка строки**: Если `jjson` является строкой, функция пытается преобразовать её в словарь с помощью `_string_to_dict(jjson)`.
4. **Обработка списка**: Если `jjson` является списком, функция применяет функцию `_decode_strings(jjson)`.
5. **Обработка словаря**: Если `jjson` является словарем, функция применяет функцию `_decode_strings(jjson)`.
6. **Обработка ошибок**: Функция обрабатывает исключения `FileNotFoundError`, `json.JSONDecodeError` и общие исключения, логирует ошибки и возвращает пустой словарь `{}` в случае ошибки.

**Примеры**:
```python
from pathlib import Path
from types import SimpleNamespace

# Пример 1: Загрузка из строки
json_string = '{"name": "John", "age": 30}'
data = j_loads(json_string)
print(data)  # Вывод: {'name': 'John', 'age': 30}

# Пример 2: Загрузка из файла
file_path = Path("data.json")
file_path.write_text('{"name": "John", "age": 30}', encoding="utf-8")  # Создаем файл data.json
data = j_loads(file_path)
print(data)  # Вывод: {'name': 'John', 'age': 30}
```

```
A (jjson, ordered)
│
├───SimpleNamespace?───Да: Преобразовать в словарь
│
├───Path?───Да:
│   │
│   ├───Директория?───Да: Рекурсивный вызов j_loads для каждого файла *.json
│   │
│   └───Файл?───Да: Чтение и парсинг JSON
│
├───Строка?───Да: Преобразование строки в словарь (_string_to_dict)
│
├───Список?───Да: Декодирование строк (_decode_strings)
│
├───Словарь?───Да: Декодирование строк (_decode_strings)
│
└───Обработка ошибок───Логирование ошибки, возврат {}
```

### `j_loads_ns`

```python
def j_loads_ns(
    jjson: Union[Path, SimpleNamespace, Dict, str], ordered: bool = True
) -> Union[SimpleNamespace, List[SimpleNamespace], Dict]:
    """Загружает JSON/CSV данные и преобразует в SimpleNamespace."""
```

**Назначение**: Функция `j_loads_ns` загружает JSON-данные из различных источников (файлы, строки, словари, объекты `SimpleNamespace`) и преобразует их в объекты `SimpleNamespace` или списки объектов `SimpleNamespace`.

**Параметры**:
- `jjson` (Union[Path, SimpleNamespace, Dict, str]): Источник JSON-данных. Может быть путем к файлу (`Path`), объектом `SimpleNamespace`, словарем (`Dict`) или строкой (`str`).
- `ordered` (bool, optional): Флаг, указывающий, нужно ли сохранять порядок элементов при загрузке данных. По умолчанию `True`.

**Возвращает**:
- `Union[SimpleNamespace, List[SimpleNamespace], Dict]`: Объект `SimpleNamespace`, список объектов `SimpleNamespace` или пустой словарь в случае ошибки или отсутствия данных.

**Как работает функция**:
1. **Загрузка данных**: Функция вызывает `j_loads(jjson, ordered=ordered)` для загрузки JSON-данных из указанного источника.
2. **Преобразование в SimpleNamespace**:
   - Если загруженные данные являются списком, функция преобразует каждый элемент списка в объект `SimpleNamespace` с помощью функции `dict2ns` и возвращает список этих объектов.
   - Если загруженные данные являются словарем, функция преобразует его в объект `SimpleNamespace` с помощью функции `dict2ns` и возвращает этот объект.
3. **Обработка пустых данных**: Если `j_loads` возвращает пустые данные (например, пустой словарь), функция возвращает пустой словарь.

**Примеры**:
```python
from pathlib import Path
from types import SimpleNamespace

# Пример 1: Загрузка из строки и преобразование в SimpleNamespace
json_string = '{"name": "John", "age": 30}'
data = j_loads_ns(json_string)
print(data)  # Вывод: namespace(name='John', age=30)
print(data.name)  # Вывод: John

# Пример 2: Загрузка из файла и преобразование в SimpleNamespace
file_path = Path("data.json")
file_path.write_text('{"name": "John", "age": 30}', encoding="utf-8")
data = j_loads_ns(file_path)
print(data)  # Вывод: namespace(name='John', age=30)
```

```
A (jjson, ordered)
│
├───Загрузка данных───data = j_loads(jjson, ordered=ordered)
│
├───Данные - список?───Да: Преобразование каждого элемента в SimpleNamespace
│   │
│   └───Данные - словарь?───Да: Преобразование в SimpleNamespace
│       │
│       └───Нет данных?───Да: Возврат {}
│           │
│           └───Нет: Возврат SimpleNamespace