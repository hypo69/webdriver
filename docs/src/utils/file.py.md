# Модуль для работы с файлами `src.utils.file`

## Обзор

Модуль `src.utils.file` предоставляет набор утилит для работы с файлами, включая функции для сохранения, чтения и поиска файлов. Он поддерживает обработку больших файлов с использованием генераторов для экономии памяти.

## Подробней

Модуль содержит функции для выполнения следующих операций:

- Сохранение данных в текстовый файл.
- Чтение содержимого файла или каталога.
- Получение списка имен файлов в каталоге.
- Рекурсивный поиск файлов по заданным шаблонам.
- Удаление BOM из текстовых файлов.

Эти функции облегчают выполнение общих операций с файлами и обеспечивают эффективную обработку больших объемов данных.

## Функции

### `save_text_file`

```python
def save_text_file(
    file_path: str | Path,
    data: str | list[str] | dict,
    mode: str = 'w'
) -> bool:
    """
    Сохраняет данные в текстовый файл.

    Args:
        file_path (str | Path): Путь к файлу для сохранения.
        data (str | list[str] | dict): Данные для записи. Могут быть строкой, списком строк или словарем.
        mode (str, optional): Режим записи файла ('w' для записи, 'a' для добавления).

    Returns:
        bool: `True`, если файл успешно сохранен, `False` в противном случае.

    Raises:
        Exception: При возникновении ошибки при записи в файл.

    Example:
        >>> from pathlib import Path
        >>> file_path = Path('example.txt')
        >>> data = 'Пример текста'
        >>> result = save_text_file(file_path, data)
        >>> print(result)
        True
    """
```

**Назначение**: Сохраняет переданные данные в файл по указанному пути.

**Параметры**:

- `file_path` (str | Path): Путь к файлу, в который будут записаны данные.
- `data` (str | list[str] | dict): Данные для записи в файл. Может быть строкой, списком строк или словарем.
- `mode` (str, optional): Режим открытия файла. По умолчанию `'w'` (запись). Может быть `'a'` (добавление).

**Возвращает**:

- `bool`: `True`, если данные успешно записаны в файл, и `False` в случае ошибки.

**Вызывает исключения**:

- `Exception`: Если возникает ошибка при записи в файл.

**Как работает функция**:

1. Преобразует `file_path` в объект `Path` для удобства работы с путями.
2. Создает родительские директории, если их нет.
3. Открывает файл в указанном режиме и кодировке UTF-8.
4. В зависимости от типа данных (`data`) записывает их в файл:
   - Если `data` является списком, записывает каждую строку из списка в файл с символом новой строки.
   - Если `data` является словарем, записывает его в файл в формате JSON с отступами.
   - Если `data` является строкой, записывает строку в файл.
5. Возвращает `True` в случае успеха, `False` в случае ошибки.

**ASCII flowchart**:

```
   Начало
     ↓
   Преобразование file_path в Path
     ↓
   Создание директорий (если нужно)
     ↓
   Открытие файла в заданном режиме
     ↓
   Проверка типа данных data
   /   |   \
  list dict строка
   \   |   /
   Запись данных в файл
     ↓
   Возврат True/False
     ↓
   Конец
```

**Примеры**:

```python
from pathlib import Path

file_path = Path('example.txt')
data = 'Пример текста'
result = save_text_file(file_path, data)
print(result)

file_path = Path('example.json')
data = {'ключ': 'значение'}
result = save_text_file(file_path, data)
print(result)

file_path = Path('example.txt')
data = ['строка 1', 'строка 2']
result = save_text_file(file_path, data, mode='a')
print(result)
```

### `read_text_file_generator`

```python
def read_text_file_generator(
    file_path: str | Path,
    as_list: bool = False,
    extensions: Optional[list[str]] = None,
    chunk_size: int = 8192,
    recursive: bool = False,
    patterns: Optional[str | list[str]] = None,
) -> Generator[str, None, None] | str | list[str] | None:
    """
    Читает содержимое файла(ов) или директории.

        Args:
            file_path (str | Path): Путь к файлу или директории.
            as_list (bool, optional): Если `True`, то возвращает генератор строк или список строк, в зависимости от типа вывода.
            extensions (list[str], optional): Список расширений файлов для включения при чтении директории.
            chunk_size (int, optional): Размер чанка для чтения файла в байтах.
            recursive (bool, optional): Если `True`, то поиск файлов выполняется рекурсивно.
            patterns (str | list[str], optional): Шаблоны для фильтрации файлов при рекурсивном поиске.

        Returns:
            Generator[str, None, None] | str | list[str] | None:
            - Если `as_list` is True и `file_path` является файлом, возвращает генератор строк.
            - Если `as_list` is True и `file_path` является директорией и `recursive` is True, возвращает список строк.
            - Если `as_list` is False и `file_path` является файлом, возвращает строку.
            - Если `as_list` is False и `file_path` является директорией, возвращает объединенную строку.
            - Возвращает `None` в случае ошибки.
        Raises:
            Exception: При возникновении ошибки при чтении файла.

        Example:
            >>> from pathlib import Path
            >>> file_path = Path('example.txt')
            >>> content = read_text_file(file_path)
            >>> if content:
            ...    print(f'File content: {content[:100]}...')
            File content: Пример текста...
    Функция read_text_file может возвращать несколько разных типов данных в зависимости от входных параметров:

    Возвращаемые значения:
    ----------------------

    - Generator[str, None, None] (Генератор строк):
        Генератор при итерации выдаёт строки из файла(ов) по одной. Эффективно для работы с большими файлами, так как они не загружаются полностью в память.
        - Когда:
            file_path – это файл и as_list равен True.
            file_path – это директория, recursive равен True и as_list равен True. При этом в генератор попадают строки из всех найденных файлов.
            file_path – это директория, recursive равен False и as_list равен True. При этом в генератор попадают строки из всех найденных файлов в текущей директории.
        
    - str (Строка):
        Содержимое файла или объединенное содержимое всех файлов в виде одной строки.
        - Когда:
            file_path – это файл и as_list равен False.
            file_path – это директория, recursive равен False и as_list равен False. При этом возвращается объединенная строка, состоящая из содержимого всех файлов в директории, разделенных символами новой строки (\\n).\
            file_path – это директория, recursive равен True и as_list равен False. При этом возвращается объединенная строка, состоящая из содержимого всех файлов в директории и её поддиректориях, разделенных символами новой строки (\\n).
 \
    - list[str] (Список строк):\
        Этот тип явно не возвращается функцией, однако когда file_path – это директория, recursive равен True и as_list равен True - функция возвращает генератор, который можно преобразовать в список при помощи list()\
        - Когда:\
            file_path – не является ни файлом, ни директорией.\
            Произошла ошибка при чтении файла или директории (например, файл не найден, ошибка доступа и т.п.).\

    Note:
        Если вы хотите прочитать содержимое файла построчно (особенно для больших файлов) используйте as_list = True. В этом случае вы получите генератор строк.\
        Если вы хотите получить всё содержимое файла в виде одной строки используйте as_list = False.\
        Если вы работаете с директорией, recursive = True будет обходить все поддиректории.\
        extensions и patterns позволят вам фильтровать файлы при работе с директорией.\
        chunk_size позволяет оптимизировать работу с большими файлами при чтении их по частям.\
        None будет возвращён в случае ошибок.

    Важно помнить:
        В случае чтения директории, если as_list=False, функция объединяет все содержимое найденных файлов в одну строку. Это может потребовать много памяти, если файлов много или они большие.\
        Функция полагается на другие функции-помощники (_read_file_lines_generator, _read_file_content, recursively_get_file_path, yield_text_from_files), которые здесь не определены и их поведение влияет на результат read_text_file.\
    """
```

**Назначение**: Читает содержимое файла или файлов в директории и возвращает его в различных форматах. Функция позволяет читать файлы построчно с использованием генератора для экономии памяти или целиком в виде строки.

**Параметры**:

- `file_path` (str | Path): Путь к файлу или директории для чтения.
- `as_list` (bool, optional): Если `True`, возвращает содержимое файла в виде генератора строк (или списка строк, если чтение идет из директории с `recursive=True`). По умолчанию `False`.
- `extensions` (list[str], optional): Список расширений файлов для включения при чтении директории. По умолчанию `None`.
- `chunk_size` (int, optional): Размер чанка (фрагмента) для чтения файла в байтах. По умолчанию `8192`.
- `recursive` (bool, optional): Если `True`, выполняет рекурсивный поиск файлов в директории и её поддиректориях. По умолчанию `False`.
- `patterns` (str | list[str], optional): Шаблоны для фильтрации файлов при рекурсивном поиске. По умолчанию `None`.

**Возвращает**:

- `Generator[str, None, None] | str | list[str] | None`:
  - Если `as_list` is `True` и `file_path` является файлом, возвращает генератор строк.
  - Если `as_list` is `True` и `file_path` является директорией и `recursive` is `True`, возвращает список строк.
  - Если `as_list` is `False` и `file_path` является файлом, возвращает строку.
  - Если `as_list` is `False` и `file_path` является директорией, возвращает объединенную строку.
  - Возвращает `None` в случае ошибки или если путь не является файлом или директорией.

**Вызывает исключения**:

- `Exception`: При возникновении ошибки при чтении файла или директории.

**Как работает функция**:

1.  Преобразует `file_path` в объект `Path`.
2.  Проверяет, является ли `file_path` файлом или директорией.
3.  Если `file_path` является файлом:
    - Если `as_list` равно `True`, возвращает результат функции `_read_file_lines_generator` (генератор строк).
    - Если `as_list` равно `False`, возвращает результат функции `_read_file_content` (строка).
4.  Если `file_path` является директорией:
    - Если `recursive` равно `True`:
      - Если `patterns` указаны, использует `recursively_get_file_path` для получения списка файлов, соответствующих шаблонам.
      - Иначе получает список всех файлов в директории и её поддиректориях, опционально фильтруя по расширениям.
      - Если `as_list` равно `True`, возвращает генератор, который итерируется по файлам и возвращает строки из каждого файла.
      - Если `as_list` равно `False`, возвращает объединенную строку, состоящую из содержимого всех файлов.
    - Если `recursive` равно `False`:
      - Получает список файлов в текущей директории, опционально фильтруя по расширениям.
      - Если `as_list` равно `True`, возвращает генератор, который итерируется по файлам и возвращает строки из каждого файла.
      - Если `as_list` равно `False`, возвращает объединенную строку, состоящую из содержимого всех файлов.
5.  Если `file_path` не является файлом или директорией, логирует ошибку и возвращает `None`.
6.  В случае возникновения исключения логирует ошибку и возвращает `None`.

**Внутренние функции**:

-   **_read_file_lines_generator(file_path: Path, chunk_size: int) -> Generator[str, None, None]**:\
    Читает файл по строкам с помощью генератора.\
    Args:\
    file_path (Path): Путь к файлу для чтения.\
    chunk_size (int): Размер чанка для чтения файла в байтах.\
    Yields:\
    str: Строки из файла.\
    Raises:\
    Exception: При возникновении ошибки при чтении файла.

-   **_read_file_content(file_path: Path, chunk_size: int) -> str**:\
    Читает содержимое файла по чанкам и возвращает как строку.\
    Args:\
    file_path (Path): Путь к файлу для чтения.\
    chunk_size (int): Размер чанка для чтения файла в байтах.\
    Returns:\
    str: Содержимое файла в виде строки.\
    Raises:\
    Exception: При возникновении ошибки при чтении файла.

**ASCII flowchart**:

```
Начало
  ↓
Преобразование file_path в Path
  ↓
Проверка: файл или директория?
  /        \
Файл      Директория
  ↓          ↓
as_list?   recursive?
/    \       /      \
True  False True    False
  ↓      ↓     ↓        ↓
_read_file_lines_generator    _read_file_content     recursively_get_file_path      Чтение файлов в текущей директории
   ↓      ↓                       ↓                     и объединение в строку
Генератор строк         Строка            Список файлов            или генератор строк
  ↓      ↓                       ↓                                 ↓
Конец   Конец                   as_list?                      Конец
                                /    \
                           True      False
                             ↓          ↓
                             Генератор строк     Объединение в строку
                             ↓          ↓
                             Конец       Конец
  ↓
Путь не является файлом или директорией
  ↓
Ошибка
  ↓
Конец
```

**Примеры**:

```python
from pathlib import Path

# Чтение файла построчно
file_path = Path('example.txt')
for line in read_text_file_generator(file_path, as_list=True):
    print(line)

# Чтение файла целиком
file_path = Path('example.txt')
content = read_text_file_generator(file_path)
if content:
    print(content[:100])

# Чтение всех txt файлов из директории рекурсивно
root_dir = Path('.')
for line in read_text_file_generator(root_dir, as_list=True, recursive=True, patterns='*.txt'):
    print(line)
```

### `read_text_file`

```python
def read_text_file(
    file_path: Union[str, Path],
    as_list: bool = False,
    extensions: Optional[list[str]] = None,
    exc_info: bool = True,
) -> str | list[str] | None:
    """
    Read the contents of a file.

    Args:
        file_path (str | Path): Path to the file or directory.
        as_list (bool, optional): If True, returns content as list of lines. Defaults to False.
        extensions (list[str], optional): List of file extensions to include if reading a directory. Defaults to None.
        exc_info (bool, optional): If True, logs traceback on error. Defaults to True.

    Returns:
        str | list[str] | None: File content as a string or list of lines, or None if an error occurs.
    """
```

**Назначение**: Читает содержимое файла и возвращает его в виде строки или списка строк.

**Параметры**:

- `file_path` (str | Path): Путь к файлу или директории.
- `as_list` (bool, optional): Если `True`, возвращает содержимое файла в виде списка строк. По умолчанию `False`.
- `extensions` (list[str], optional): Список расширений файлов, которые следует включать при чтении директории. По умолчанию `None`.
- `exc_info` (bool, optional): Если `True`, при возникновении ошибки в журнал будет записана трассировка стека. По умолчанию `True`.

**Возвращает**:

- `str | list[str] | None`: Содержимое файла в виде строки или списка строк, или `None`, если произошла ошибка.

**Как работает функция**:

1. Преобразует `file_path` в объект `Path`.
2. Проверяет, является ли `file_path` файлом или директорией.
3. Если `file_path` является файлом:
   - Открывает файл в режиме чтения с кодировкой UTF-8.
   - Если `as_list` равно `True`, возвращает список строк, прочитанных из файла.
   - Если `as_list` равно `False`, возвращает содержимое файла в виде строки.
4. Если `file_path` является директорией:
   - Получает список файлов в директории, фильтруя их по расширениям, если они указаны.
   - Рекурсивно читает содержимое каждого файла в директории.
   - Если `as_list` равно `True`, возвращает список списков строк (объединенный в один список).
   - Если `as_list` равно `False`, возвращает объединенное содержимое всех файлов в виде одной строки.
5. Если `file_path` не является файлом или директорией, записывает предупреждение в журнал и возвращает `None`.
6. В случае возникновения исключения записывает ошибку в журнал и возвращает `None`.

**ASCII flowchart**:

```
Начало
 ↓
Преобразование file_path в Path
 ↓
Проверка: файл или директория?
 /       \
Файл     Директория
 ↓        ↓
Открытие файла   Получение списка файлов
 ↓        ↓
as_list?     Рекурсивное чтение файлов
 /   \       ↓
True  False  as_list?
 ↓    ↓     /   \
Список строк  Строка True  False
             ↓    ↓
    Список списков строк  Объединенная строка
 ↓       ↓
Конец    Конец
 ↓
Путь не является файлом или директорией
 ↓
Ошибка
 ↓
Конец
```

**Примеры**:

```python
from pathlib import Path

# Чтение файла построчно
file_path = Path('example.txt')
lines = read_text_file(file_path, as_list=True)
if lines:
    for line in lines:
        print(line)

# Чтение файла целиком
file_path = Path('example.txt')
content = read_text_file(file_path)
if content:
    print(content[:100])

# Чтение всех txt файлов из директории в виде списка строк
root_dir = Path('.')
all_lines = read_text_file(root_dir, as_list=True, extensions=['txt'])
if all_lines:
    for line in all_lines:
        print(line)
```

### `yield_text_from_files`

```python
def yield_text_from_files(
    file_path: str | Path,
    as_list: bool = False,
    chunk_size: int = 8192
) -> Generator[str, None, None] | str | None:
    """
    Читает содержимое файла и возвращает его в виде генератора строк или одной строки.

    Args:
        file_path (str | Path): Путь к файлу.
        as_list (bool, optional): Если True, возвращает генератор строк. По умолчанию False.
        chunk_size (int, optional): Размер чанка для чтения файла в байтах.

    Returns:
        Generator[str, None, None] | str | None: Генератор строк, объединенная строка или None в случае ошибки.

    Yields:
       str: Строки из файла, если as_list is True.

    Example:
        >>> from pathlib import Path
        >>> file_path = Path('example.txt')
        >>> for line in yield_text_from_files(file_path, as_list=True):
        ...     print(line)
        Первая строка файла
        Вторая строка файла
    """
```

**Назначение**: Читает содержимое файла и возвращает его в виде генератора строк или одной строки.

**Параметры**:

- `file_path` (str | Path): Путь к файлу.
- `as_list` (bool, optional): Если `True`, возвращает генератор строк. По умолчанию `False`.
- `chunk_size` (int, optional): Размер чанка для чтения файла в байтах.

**Возвращает**:

- `Generator[str, None, None] | str | None`: Генератор строк, объединенная строка или `None` в случае ошибки.

**Yields**:

- `str`: Строки из файла, если `as_list` is `True`.

**Как работает функция**:

1. Преобразует `file_path` в объект `Path`.
2. Проверяет, является ли `file_path` файлом.
3. Если `file_path` является файлом:
   - Если `as_list` равно `True`, вызывает функцию `_read_file_lines_generator` и возвращает генератор строк.
   - Если `as_list` равно `False`, вызывает функцию `_read_file_content` и возвращает строку.
4. Если `file_path` не является файлом, логирует ошибку и возвращает `None`.
5. В случае возникновения исключения логирует ошибку и возвращает `None`.

**ASCII flowchart**:

```
Начало
 ↓
Преобразование file_path в Path
 ↓
Проверка: файл?
 /   \
True False
 ↓    ↓
as_list?  Логирование ошибки
/   \   ↓
True False  return None
↓    ↓
_read_file_lines_generator  _read_file_content
↓    ↓
Генератор строк  Строка
↓    ↓
Конец Конец
```

**Примеры**:

```python
from pathlib import Path

# Чтение файла построчно с использованием генератора
file_path = Path('example.txt')
for line in yield_text_from_files(file_path, as_list=True):
    print(line)

# Чтение файла целиком
file_path = Path('example.txt')
content = yield_text_from_files(file_path)
if content:
    print(content[:100])
```

### `_read_file_content`

```python
def _read_file_content(file_path: Path, chunk_size: int) -> str:
    """
    Читает содержимое файла по чанкам и возвращает как строку.

    Args:
        file_path (Path): Путь к файлу для чтения.
        chunk_size (int): Размер чанка для чтения файла в байтах.
    Returns:
        str: Содержимое файла в виде строки.
    Raises:
        Exception: При возникновении ошибки при чтении файла.
    """
```

**Назначение**: Читает содержимое файла по частям (чанкам) и объединяет их в одну строку.

**Параметры**:

- `file_path` (Path): Путь к файлу.
- `chunk_size` (int): Размер чанка в байтах.

**Возвращает**:

- `str`: Содержимое файла в виде строки.

**Вызывает исключения**:

- `Exception`: При возникновении ошибки при чтении файла.

**Как работает функция**:

1. Открывает файл в режиме чтения с кодировкой UTF-8.
2. Читает файл по частям размером `chunk_size` в цикле, пока не достигнет конца файла.
3. Объединяет прочитанные части в одну строку.
4. Возвращает полученную строку.

**ASCII flowchart**:

```
Начало
 ↓
Открытие файла
 ↓
Цикл: чтение чанка
 ↓
Конец файла?
 /   \
Да  Нет
 ↓    ↓
Закрытие файла   Объединение чанка в строку
 ↓    ↓
Возврат строки  Продолжение цикла
 ↓
Конец
```

**Примеры**:

```python
from pathlib import Path

file_path = Path('example.txt')
content = _read_file_content(file_path, chunk_size=1024)
print(content[:100])
```

### `_read_file_lines_generator`

```python
def _read_file_lines_generator(file_path: Path, chunk_size: int) -> Generator[str, None, None]:
    """
    Читает файл по строкам с помощью генератора.

    Args:
        file_path (Path): Путь к файлу для чтения.
        chunk_size (int): Размер чанка для чтения файла в байтах.
    Yields:
        str: Строки из файла.
    Raises:
        Exception: При возникновении ошибки при чтении файла.
    """
```

**Назначение**: Читает файл по частям (чанкам) и разделяет их на строки, возвращая строки с использованием генератора.

**Параметры**:

- `file_path` (Path): Путь к файлу.
- `chunk_size` (int): Размер чанка в байтах.

**Yields**:

- `str`: Строки из файла.

**Вызывает исключения**:

- `Exception`: При возникновении ошибки при чтении файла.

**Как работает функция**:

1. Открывает файл в режиме чтения с кодировкой UTF-8.
2. Читает файл по частям размером `chunk_size` в цикле, пока не достигнет конца файла.
3. Разделяет каждую часть на строки с использованием `splitlines()`.
4. Если чанк не заканчивается полной строкой (т.е. не заканчивается символом новой строки), добавляет последнюю строку из текущего чанка к следующему чанку.
5. Возвращает строки с использованием `yield from`.

**ASCII flowchart**:

```
Начало
 ↓
Открытие файла
 ↓
Цикл: чтение чанка
 ↓
Конец файла?
 /   \
Да  Нет
 ↓    ↓
Закрытие файла   Разделение чанка на строки
 ↓    ↓
Конец   Чанк заканчивается новой строкой?
 /   \
Да  Нет
↓    ↓
Возврат строк   Добавление последней строки к следующему чанку
↓    ↓
Продолжение цикла  Продолжение цикла
```

**Примеры**:

```python
from pathlib import Path

file_path = Path('example.txt')
for line in _read_file_lines_generator(file_path, chunk_size=1024):
    print(line)
```

### `get_filenames_from_directory`

```python
def get_filenames_from_directory(
    directory: str | Path, ext: str | list[str] = '*'
) -> list[str]:
    """
    Возвращает список имен файлов в директории, опционально отфильтрованных по расширению.

    Args:
        directory (str | Path): Путь к директории для поиска.
        ext (str | list[str], optional): Расширения для фильтрации.
            По умолчанию '*'.

    Returns:
        list[str]: Список имен файлов, найденных в директории.

    Example:
        >>> from pathlib import Path
        >>> directory = Path('.')
        >>> get_filenames_from_directory(directory, ['.txt', '.md'])
        ['example.txt', 'readme.md']
    """
```

**Назначение**: Возвращает список имен файлов в указанной директории, с возможностью фильтрации по расширению.

**Параметры**:

- `directory` (str | Path): Путь к директории, в которой нужно получить список файлов.
- `ext` (str | list[str], optional): Расширение или список расширений файлов для фильтрации. Если указана строка `'*'`, фильтрация не производится. По умолчанию `'*'`.

**Возвращает**:

- `list[str]`: Список имен файлов, найденных в директории.

**Как работает функция**:

1.  Проверяет, является ли указанный путь директорией. Если нет, записывает сообщение об ошибке и возвращает пустой список.
2.  Преобразует параметр `ext` в список расширений, если он задан строкой. Если `ext` равен `'*'`, создает пустой список расширений.
3.  Добавляет точку к каждому расширению, если её нет.
4.  Создает список имен файлов, которые являются файлами и соответствуют указанным расширениям (если они указаны).
5.  В случае возникновения исключения записывает сообщение об ошибке и возвращает пустой список.

**ASCII flowchart**:

```
Начало
 ↓
Проверка: является ли directory директорией?
 /   \
Нет  Да
 ↓    ↓
Логирование ошибки  Преобразование ext в список расширений
 ↓    ↓
Возврат []   Добавление точки к расширениям (если необходимо)
 ↓    ↓
Конец  Создание списка имен файлов
 ↓
В случае ошибки: логирование ошибки и возврат []
 ↓
Конец
```

**Примеры**:

```python
from pathlib import Path

# Получение списка всех файлов в текущей директории
directory = Path('.')
files = get_filenames_from_directory(directory)
print(files)

# Получение списка файлов с расширениями .txt и .md
directory = Path('.')
files = get_filenames_from_directory(directory, ['.txt', '.md'])
print(files)
```

### `recursively_yield_file_path`

```python
def recursively_yield_file_path(
    root_dir: str | Path, patterns: str | list[str] = '*'
) -> Generator[Path, None, None]:
    """
    Рекурсивно возвращает пути ко всем файлам, соответствующим заданным шаблонам, в указанной директории.

    Args:
        root_dir (str | Path): Корневая директория для поиска.
        patterns (str | list[str]): Шаблоны для фильтрации файлов.

    Yields:
        Path: Путь к файлу, соответствующему шаблону.

    Example:
        >>> from pathlib import Path
        >>> root_dir = Path('.')
        >>> for path in recursively_yield_file_path(root_dir, ['*.txt', '*.md']):
        ...    print(path)
        ./example.txt
        ./readme.md
    """
```

**Назначение**: Рекурсивно обходит указанную директорию и возвращает пути ко всем файлам, соответствующим заданным шаблонам, с использованием генератора.

**Параметры**:

- `root_dir` (str | Path): Корневая директория для поиска файлов.
- `patterns` (str | list[str], optional): Шаблон или список шаблонов для фильтрации файлов. По умолчанию `'*'` (все файлы).

**Yields**:

- `Path`: Путь к файлу, соответствующему заданному шаблону.

**Как работает функция**:

1. Преобразует параметр `patterns` в список, если он задан строкой.
2. Перебирает шаблоны в списке и для каждого шаблона использует `Path(root_dir).rglob(pattern)` для рекурсивного поиска файлов, соответствующих шаблону.
3. Возвращает пути к файлам с использованием `yield from`.
4. В случае возникновения исключения записывает сообщение об ошибке в журнал.

**ASCII flowchart**:

```
Начало
 ↓
Преобразование patterns в список
 ↓
Цикл по шаблонам
 ↓
Рекурсивный поиск файлов, соответствующих шаблону
 ↓
Возврат пути к файлу (yield)
 ↓
Конец цикла
 ↓
В случае ошибки: логирование ошибки
 ↓
Конец
```

**Примеры**:

```python
from pathlib import Path

# Рекурсивный поиск всех файлов с расширением .txt и .md в текущей директории
root_dir = Path('.')
for path in recursively_yield_file_path(root_dir, ['*.txt', '*.md']):
    print(path)
```

### `recursively_get_file_path`

```python
def recursively_get_file_path(
    root_dir: str | Path,
    patterns: str | list[str] = '*'
) -> list[Path]:
    """
    Рекурсивно возвращает список путей ко всем файлам, соответствующим заданным шаблонам, в указанной директории.

    Args:
        root_dir (str | Path): Корневая директория для поиска.
        patterns (str | list[str]): Шаблоны для фильтрации файлов.

    Returns:
        list[Path]: Список путей к файлам, соответствующим шаблонам.

    Example:
        >>> from pathlib import Path
        >>> root_dir = Path('.')
        >>> paths = recursively_get_file_path(root_dir, ['*.txt', '*.md'])
        >>> print(paths)
        [Path('./example.txt'), Path('./readme.md')]
    """
```

**Назначение**: Рекурсивно об