# Модуль ToolBox_main
## Обзор

Модуль `ToolBox_main.py` представляет собой основной файл для управления Telegram-ботом `ToolBox`. 
Он обрабатывает различные команды и запросы пользователей, взаимодействует с базой данных для хранения информации о пользователях и их подписках, 
а также предоставляет функциональность для генерации текста и изображений.

## Подробнее

Этот модуль является сердцем Telegram-бота, обеспечивая взаимодействие с пользователями, обработку их запросов и управление подписками.
Он использует базу данных для хранения информации о пользователях и их тарифных планах, а также предоставляет функции для генерации текста и изображений.

## Классы

В данном модуле напрямую классы не определены. Он использует классы из других модулей:
### `ToolBox`

**Описание**: Класс `ToolBox` используется для выполнения различных задач, связанных с ботом, таких как отправка сообщений, обработка команд и управление интерфейсом.

### `DataBase`

**Описание**: Класс `DataBase` предназначен для взаимодействия с базой данных, включая создание, подключение и выполнение операций CRUD (Create, Read, Update, Delete) для хранения данных пользователей.

## Функции

### `process_pre_checkout_query`

```python
def process_pre_checkout_query(pre_checkout_query: types.PreCheckoutQuery) -> None:
    """Обрабатывает предварительный запрос перед оплатой.

    Args:
        pre_checkout_query (types.PreCheckoutQuery): Объект запроса перед оплатой.

    Returns:
        None

    Как работает функция:
    1. Принимает запрос перед оплатой от пользователя.
    2. Подтверждает возможность проведения оплаты, отправляя ответ `ok=True`.
    """
```
**Параметры**:
- `pre_checkout_query` (types.PreCheckoutQuery): Объект запроса перед оплатой.

**Возвращает**:
- `None`

```
A [Прием запроса перед оплатой]
|
B [Подтверждение возможности оплаты]
```

### `successful_payment`

```python
@bot.message_handler(content_types=['successful_payment'])
def successful_payment(message: types.Message) -> None:
    """Обрабатывает успешный платеж.

    Args:
        message (types.Message): Объект сообщения об успешном платеже.

    Returns:
        None
    """
```

**Параметры**:
- `message` (types.Message): Объект сообщения об успешном платеже.

**Возвращает**:
- `None`

**Как работает функция**:
1. Извлекает ID пользователя из сообщения.
2. Определяет, какой тариф был оплачен (basic или pro) на основе `invoice_payload`.
3. Обновляет информацию о подписке пользователя в базе данных.
4. Начисляет токены пользователю в зависимости от тарифа.
5. Устанавливает дату окончания подписки на 1 месяц вперед.
6. Обновляет данные в базе данных и отправляет пользователю подтверждающее сообщение.
7. Перезапускает взаимодействие с пользователем через `tb.restart(message)`.

```
A [Получение сообщения об успешной оплате]
|
B [Определение типа тарифа]
|
C [Обновление данных о подписке в БД]
|
D [Начисление токенов]
|
E [Установка даты окончания подписки]
|
F [Отправка подтверждения пользователю]
```

### `StartProcessing`

```python
@bot.message_handler(commands=['start'])
def StartProcessing(message: types.Message) -> None:
    """Обрабатывает команду /start.

    Args:
        message (types.Message): Объект сообщения с командой /start.

    Returns:
        None
    """
```

**Параметры**:
- `message` (types.Message): Объект сообщения с командой /start.

**Возвращает**:
- `None`

**Как работает функция**:
1. Извлекает ID пользователя из сообщения.
2. Проверяет, существует ли пользователь в базе данных.
3. Если пользователя нет, создает запись с данными по умолчанию (`DATA_PATTERN`).
4. Если пользователь существует, обновляет его данные, сохраняя информацию о подписке, токенах и реферальной программе.
5. Обновляет данные в базе данных и отправляет пользователю стартовое сообщение через `tb.start_request(message)`.

```
A [Получение команды /start]
|
B [Проверка наличия пользователя в БД]
|
C [Создание/обновление данных пользователя]
|
D [Отправка стартового сообщения]
```

### `personal_account`

```python
@bot.message_handler(commands=['profile'])
def personal_account(message: types.Message) -> None:
    """Отображает информацию о тарифном плане пользователя.

    Args:
        message (types.Message): Объект сообщения с командой /profile.

    Returns:
        None
    """
```

**Параметры**:
- `message` (types.Message): Объект сообщения с командой /profile.

**Возвращает**:
- `None`

**Как работает функция**:
1. Извлекает ID пользователя из сообщения.
2. Проверяет наличие подписки BASIC и PRO у пользователя.
3. Отправляет сообщение с информацией о тарифном плане пользователя (BASIC, PRO или отсутствие подписки) через `bot.send_message`.

```
A [Получение команды /profile]
|
B [Проверка типа подписки пользователя]
|
C [Отправка информации о тарифном плане]
```

### `show_stat`

```python
@bot.message_handler(commands=['stat'])
def show_stat(message: types.Message) -> None:
    """Отображает статистику бота (только для администраторов).

    Args:
        message (types.Message): Объект сообщения с командой /stat.

    Returns:
        None
    """
```

**Параметры**:
- `message` (types.Message): Объект сообщения с командой /stat.

**Возвращает**:
- `None`

**Как работает функция**:
1. Извлекает ID пользователя из сообщения.
2. Проверяет, является ли пользователь администратором (ID пользователя в списке `['2004851715', '206635551']`).
3. Отправляет статистику бота (общее количество пользователей и количество пользователей с промокодом) через `bot.send_message`.

```
A [Получение команды /stat]
|
B [Проверка прав администратора]
|
C [Отправка статистики]
```

### `generate_promo_code`

```python
def generate_promo_code(length: int) -> str:
    """Генерирует случайный промокод заданной длины.

    Args:
        length (int): Длина промокода.

    Returns:
        str: Сгенерированный промокод.
    """
```

**Параметры**:
- `length` (int): Длина промокода.

**Возвращает**:
- `str`: Сгенерированный промокод.

**Как работает функция**:
1. Определяет набор символов для генерации промокода (буквы и цифры).
2. Генерирует случайный промокод заданной длины с использованием `random.choices` и `join`.
3. Возвращает сгенерированный промокод.

```
A [Определение набора символов]
|
B [Генерация промокода]
|
C [Возврат промокода]
```

### `CallsProcessing`

```python
@bot.callback_query_handler(func=lambda call: True)
def CallsProcessing(call: types.CallbackQuery) -> None:
    """Обрабатывает все callback-запросы от inline-кнопок.

    Args:
        call (types.CallbackQuery): Объект callback-запроса.

    Returns:
        None
    """
```

**Параметры**:
- `call` (types.CallbackQuery): Объект callback-запроса.

**Возвращает**:
- `None`

**Как работает функция**:
1. Извлекает ID пользователя из callback-запроса.
2. Создает данные пользователя, если их нет в базе данных.
3. Обрабатывает различные типы callback-запросов, такие как:
   - Запросы кнопок основного меню (`tb.data`).
   - Запросы кнопок выбора размера изображения.
   - Запросы кнопок тарифов.
   - Запросы кнопок текстовых задач.
   - Запросы кнопок выхода из различных меню.
   - Запросы кнопок для выбора одной или нескольких текстовых областей.
4. Вызывает соответствующие функции `ToolBox` для обработки запросов и обновления интерфейса бота.

```
A [Получение callback-запроса]
|
B [Создание данных пользователя (при необходимости)]
|
C [Обработка различных типов запросов]
|
D [Вызов функций ToolBox для обработки запросов]
```

### `TokensCancelletionPattern`

```python
def TokensCancelletionPattern(user_id: str, func: callable, message: types.Message, i: Optional[int] = None) -> None:
    """Обрабатывает списания токенов или запросов для пользователя.

    Args:
        user_id (str): ID пользователя.
        func (callable): Функция для выполнения.
        message (types.Message): Объект сообщения.
        i (Optional[int], optional): Индекс для текстовых команд. По умолчанию None.

    Returns:
        None
    """
```

**Параметры**:
- `user_id` (str): ID пользователя.
- `func` (callable): Функция для выполнения.
- `message` (types.Message): Объект сообщения.
- `i` (Optional[int], optional): Индекс для текстовых команд. По умолчанию `None`.

**Возвращает**:
- `None`

**Как работает функция**:
1. Извлекает информацию о количестве входящих и исходящих токенов, а также о количестве бесплатных запросов пользователя из базы данных.
2. Проверяет, достаточно ли у пользователя токенов или бесплатных запросов для выполнения операции.
3. Вызывает переданную функцию `func` для выполнения операции.
4. Обновляет количество токенов или бесплатных запросов пользователя в зависимости от типа операции.
5. Если у пользователя заканчиваются токены или бесплатные запросы, отправляет сообщение об окончании тарифа и перезапускает взаимодействие с пользователем.

```
A [Получение данных о токенах и запросах пользователя]
|
B [Проверка доступности токенов/запросов]
|
C [Выполнение операции]
|
D [Обновление количества токенов/запросов]
|
E [Обработка окончания тарифа]
```

### `TasksProcessing`

```python
@bot.message_handler(func=lambda message: True, content_types=['text', 'photo'])
def TasksProcessing(message: types.Message) -> None:
    """Обрабатывает входящие текстовые и графические сообщения.

    Args:
        message (types.Message): Объект входящего сообщения.

    Returns:
        None
    """
```

**Параметры**:
- `message` (types.Message): Объект входящего сообщения.

**Возвращает**:
- `None`

**Как работает функция**:
1. Извлекает ID пользователя из сообщения.
2. Обрабатывает различные типы сообщений:
   - Генерация изображений: Если у пользователя запрошена генерация изображения, функция извлекает размер изображения и текст запроса, генерирует изображение с помощью `tb.ImageCommand` и сохраняет информацию о запросе в базе данных.
   - Выход в главное меню из бесплатного режима: Если пользователь находится в бесплатном режиме и отправляет сообщение "В меню", функция завершает сессию и возвращает пользователя в главное меню.
   - Обработка сообщений в бесплатном режиме: Если пользователь находится в бесплатном режиме, функция обрабатывает текстовые и графические сообщения с помощью `tb.FreeCommand` и обновляет историю сессии.
   - Обработка текстовых задач: Если у пользователя выбрана одна или несколько текстовых задач, функция вызывает соответствующие функции `tb.TextCommands` или `tb.SomeTextsCommand` для обработки задачи и списания токенов.
3. Обновляет данные пользователя в базе данных.

```
A [Получение входящего сообщения]
|
B [Обработка различных типов сообщений]
|
C [Генерация изображений]
|
D [Выход в главное меню из бесплатного режима]
|
E [Обработка сообщений в бесплатном режиме]
|
F [Обработка текстовых задач]
|
G [Обновление данных пользователя в БД]
```

### `end_check_tariff_time`

```python
async def end_check_tariff_time() -> None:
    """Проверяет время окончания тарифного плана у пользователей и сбрасывает тариф при необходимости.

    Returns:
        None
    """
```

**Параметры**:
- Нет

**Возвращает**:
- `None`

**Как работает функция**:
1. Запускает бесконечный цикл.
2. Проходит по всем пользователям в базе данных.
3. Проверяет, истекло ли время действия тарифного плана пользователя (`datetime_sub`).
4. Если время истекло, сбрасывает данные пользователя к значениям по умолчанию (`DATA_PATTERN`), сохраняя информацию о тексте, изображениях, промокоде и реферальной программе.
5. Обновляет данные пользователя в базе данных.
6. Приостанавливает выполнение на 10 секунд с помощью `asyncio.sleep(10)`.

```
A [Запуск бесконечного цикла]
|
B [Проход по всем пользователям]
|
C [Проверка времени окончания тарифа]
|
D [Сброс данных пользователя (при необходимости)]
|
E [Обновление данных в БД]
|
F [Пауза в 10 секунд]
```

## Запуск бота

```python
if __name__ == "__main__":
    Thread(target=bot.infinity_polling).start()
    asyncio.run(end_check_tariff_time())
```

**Как работает**:
1. Запускает бота в отдельном потоке с помощью `Thread(target=bot.infinity_polling).start()`. Это позволяет боту постоянно опрашивать сервер Telegram на наличие новых сообщений и команд.
2. Запускает асинхронную функцию `end_check_tariff_time()` для проверки времени окончания тарифных планов пользователей.

**Примеры**:

Пример запуска бота:
```bash
python ToolBox_main.py