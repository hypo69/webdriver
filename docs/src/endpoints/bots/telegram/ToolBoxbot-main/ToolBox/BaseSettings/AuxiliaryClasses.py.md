# Модуль AuxiliaryClasses.py

## Обзор

Модуль содержит вспомогательные классы `keyboards` и `PromptsCompressor`, предназначенные для работы с клавиатурами Telegram бота и компрессией промптов соответственно. Класс `keyboards` предоставляет методы для создания различных типов клавиатур, а класс `PromptsCompressor` - для получения и обработки текстовых промптов.

## Подробней

Этот модуль предоставляет классы для упрощения создания клавиатур Telegram бота и обработки промптов. Класс `keyboards` содержит методы для создания инлайн и ответных клавиатур, а класс `PromptsCompressor` - для получения промптов из JSON файла, их компрессии и вставки HTML тегов. Эти классы облегчают разработку и поддержку бота, предоставляя готовые инструменты для работы с пользовательским интерфейсом и генерацией контента.

## Классы

### `keyboards`

**Описание**: Класс `keyboards` предназначен для создания различных типов клавиатур для Telegram бота.

**Принцип работы**:
Класс содержит методы для создания инлайн и ответных клавиатур. Инлайн клавиатуры создаются с использованием `types.InlineKeyboardMarkup` и позволяют добавлять кнопки с callback данными. Ответные клавиатуры создаются с использованием `types.ReplyKeyboardMarkup` и позволяют пользователю выбирать один из предложенных вариантов ответа.

**Методы**:

- `_keyboard_two_blank(data: list[str], name: list[str]) -> types.InlineKeyboardMarkup`
- `_reply_keyboard(self, name: list[str])`

#### `_keyboard_two_blank`

```python
def _keyboard_two_blank(self, data: list[str], name: list[str]) -> types.InlineKeyboardMarkup:
    """Создает инлайн клавиатуру с кнопками в два столбца.

    Args:
        data (list[str]): Список callback данных для кнопок.
        name (list[str]): Список названий кнопок.

    Returns:
        types.InlineKeyboardMarkup: Объект инлайн клавиатуры.

    Как работает функция:
    1.  Инициализация клавиатуры:
        - Создается объект `types.InlineKeyboardMarkup` для формирования инлайн клавиатуры.

    2.  Создание кнопок:
        - Происходит итерация по спискам `data` и `name` одновременно.
        - На каждой итерации создается объект `types.InlineKeyboardButton`, которому присваивается текст из списка `name` и callback-данные из списка `data`.

    3.  Добавление кнопок на клавиатуру:
        - Если количество кнопок четное, они добавляются попарно в строку.
        - Если количество кнопок нечетное, все кнопки, кроме последней, добавляются попарно, а последняя кнопка добавляется в отдельную строку.

    4.  Возврат клавиатуры:
        - Сформированная инлайн клавиатура возвращается.

    ASCII flowchart:
    Создание клавиатуры
    │
    Создание кнопок
    │
    Добавление кнопок на клавиатуру
    │
    Возврат клавиатуры
    """
    ...
```

**Параметры**:

- `data` (list[str]): Список callback данных для кнопок.
- `name` (list[str]): Список названий кнопок.

**Возвращает**:

- `types.InlineKeyboardMarkup`: Объект инлайн клавиатуры.

**Примеры**:

```python
from telebot import types

data = ['1', '2', '3', '4']
name = ['Button 1', 'Button 2', 'Button 3', 'Button 4']
keyboard = keyboards()._keyboard_two_blank(data, name)
# keyboard будет содержать InlineKeyboardMarkup с четырьмя кнопками в два столбца
```

#### `_reply_keyboard`

```python
def _reply_keyboard(self, name: list[str]):
    """Создает ответную клавиатуру.

    Args:
        name (list[str]): Список названий кнопок.

    Returns:
        types.ReplyKeyboardMarkup: Объект ответной клавиатуры.

    Как работает функция:
    1.  Инициализация клавиатуры:
        - Создается объект `types.ReplyKeyboardMarkup` для формирования ответной клавиатуры.

    2.  Создание кнопок:
        - Происходит итерация по списку `name`.
        - На каждой итерации создается объект `types.KeyboardButton`, которому присваивается текст из списка `name`.

    3.  Добавление кнопок на клавиатуру:
        - Каждая кнопка добавляется на клавиатуру.

    4.  Возврат клавиатуры:
        - Сформированная ответная клавиатура возвращается.

    ASCII flowchart:
    Создание клавиатуры
    │
    Создание кнопок
    │
    Добавление кнопок на клавиатуру
    │
    Возврат клавиатуры
    """
    ...
```

**Параметры**:

- `name` (list[str]): Список названий кнопок.

**Возвращает**:

- `types.ReplyKeyboardMarkup`: Объект ответной клавиатуры.

**Примеры**:

```python
from telebot import types

name = ['Button 1', 'Button 2', 'Button 3']
keyboard = keyboards()._reply_keyboard(name)
# keyboard будет содержать ReplyKeyboardMarkup с тремя кнопками
```

### `PromptsCompressor`

**Описание**: Класс `PromptsCompressor` предназначен для получения и обработки текстовых промптов.

**Принцип работы**:
Класс содержит методы для получения промптов из JSON файла, их компрессии путем замены определенных маркеров на значения из списка, и вставки HTML тегов в текст ответа.

**Методы**:

- `__init__(self)`
- `get_prompt(self, info: list[str], ind: int) -> str`
- `html_tags_insert(response: str) -> str`

#### `__init__`

```python
def __init__(self):
    """Инициализирует класс `PromptsCompressor`.

    Attributes:
        commands_size (list[list[str]]): Список размеров команд для различных промптов.
    """
    ...
```

**Атрибуты**:

- `commands_size` (list[list[str]]): Список размеров команд для различных промптов.

**Примеры**:

```python
compressor = PromptsCompressor()
# Создается экземпляр класса PromptsCompressor
```

#### `get_prompt`

```python
def get_prompt(self, info: list[str], ind: int) -> str:
    """Получает промпт из JSON файла и заменяет маркеры на значения из списка.

    Args:
        info (list[str]): Список значений для замены маркеров в промпте.
        ind (int): Индекс промпта в JSON файле.

    Returns:
        str: Сформированный промпт.

    Как работает функция:
    1.  Чтение промптов из файла:
        - Открывается файл `ToolBox/BaseSettings/prompts.json` для чтения.
        - Загружаются данные из JSON файла, и выбирается команда с индексом `ind`.

    2.  Замена маркеров:
        - Происходит итерация по списку `self.commands_size[ind]` и списку `info` одновременно.
        - На каждой итерации маркер в команде заменяется соответствующим значением из списка `info`.

    3.  Возврат промпта:
        - Сформированный промпт возвращается.

    ASCII flowchart:
    Чтение промптов из файла
    │
    Замена маркеров
    │
    Возврат промпта
    """
    ...
```

**Параметры**:

- `info` (list[str]): Список значений для замены маркеров в промпте.
- `ind` (int): Индекс промпта в JSON файле.

**Возвращает**:

- `str`: Сформированный промпт.

**Примеры**:

```python
compressor = PromptsCompressor()
info = ['Topic', 'TA', 'Tone', 'Struct', 'Length', 'Extra']
ind = 0
prompt = compressor.get_prompt(info, ind)
# prompt будет содержать сформированный промпт с замененными маркерами
```

#### `html_tags_insert`

```python
@staticmethod
def html_tags_insert(response: str) -> str:
    """Вставляет HTML теги в текст ответа.

    Args:
        response (str): Текст ответа.

    Returns:
        str: Текст ответа с вставленными HTML тегами.

    Как работает функция:
    1.  Определение шаблонов:
        - Определяются шаблоны для поиска и замены текста.

    2.  Замена текста:
        - Происходит итерация по списку шаблонов.
        - На каждой итерации текст ответа обрабатывается с использованием `re.sub` для замены текста в соответствии с шаблоном.

    3.  Возврат обработанного текста:
        - Обработанный текст ответа возвращается.

    ASCII flowchart:
    Определение шаблонов
    │
    Замена текста
    │
    Возврат обработанного текста
    """
    ...
```

**Параметры**:

- `response` (str): Текст ответа.

**Возвращает**:

- `str`: Текст ответа с вставленными HTML тегами.

**Примеры**:

```python
response = '#### Заголовок 1\n### Заголовок 2\n**Жирный текст**\n*Курсив*'
html_response = PromptsCompressor.html_tags_insert(response)
# html_response будет содержать текст с вставленными HTML тегами
```