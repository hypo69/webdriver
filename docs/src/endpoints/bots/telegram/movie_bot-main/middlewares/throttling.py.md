# Модуль ThrottlingMiddleware

## Обзор

Модуль `ThrottlingMiddleware` предоставляет класс `ThrottlingMiddleware`, который является промежуточным слоем (middleware) для aiogram, предназначенным для ограничения частоты запросов от пользователей в Telegram-боте. Он использует `TTLCache` для хранения информации о том, когда пользователь последний раз обращался к боту, и предотвращает обработку запросов, если они поступают слишком часто.

## Подробнее

Этот модуль помогает защитить бота от злоупотреблений и спама, ограничивая количество сообщений, которые пользователь может отправлять за определенный период времени. Он предотвращает перегрузку сервера и обеспечивает более стабильную работу бота.

## Классы

### `ThrottlingMiddleware`

**Описание**: Класс `ThrottlingMiddleware` реализует механизм ограничения частоты запросов.

**Наследует**:
- `BaseMiddleware` из библиотеки `aiogram`.

**Атрибуты**:
- `limit` (TTLCache): Кэш, хранящий информацию о времени последнего обращения пользователя к боту.

**Методы**:
- `__init__(time_limit: int = 2) -> None`: Инициализирует объект `ThrottlingMiddleware` с заданным временем ограничения.
- `__call__(handler: Callable[[Message, Dict[str, Any]], Awaitable[Any]], event: Message, data: Dict[str, Any]) -> Any`: Вызывается для каждого входящего сообщения. Проверяет, не превышен ли лимит запросов для данного пользователя, и либо пропускает сообщение для дальнейшей обработки, либо игнорирует его.

## Функции

### `__init__`

```python
def __init__(self, time_limit: int = 2) -> None:
    """Инициализирует объект `ThrottlingMiddleware` с заданным временем ограничения.

    Args:
        time_limit (int, optional): Время в секундах, в течение которого разрешен только один запрос от пользователя. По умолчанию 2 секунды.

    """
```

**Назначение**: Инициализация экземпляра класса `ThrottlingMiddleware`. Устанавливает время ограничения для запросов и создает кэш для хранения информации о пользователях.

**Параметры**:
- `time_limit` (int, optional): Время в секундах, в течение которого разрешен только один запрос от пользователя. По умолчанию 2 секунды.

**Как работает функция**:
1. Функция инициализирует атрибут `limit` как экземпляр класса `TTLCache` с максимальным размером 10 000 элементов и временем жизни (TTL), равным `time_limit`.

**Примеры**:
```python
middleware = ThrottlingMiddleware(time_limit=3)
```

### `__call__`

```python
async def __call__(
    self,
    handler: Callable[[Message, Dict[str, Any]], Awaitable[Any]],
    event: Message,
    data: Dict[str, Any]
) -> Any:
    """Вызывается для каждого входящего сообщения. Проверяет, не превышен ли лимит запросов для данного пользователя, и либо пропускает сообщение для дальнейшей обработки, либо игнорирует его.

    Args:
        handler (Callable[[Message, Dict[str, Any]], Awaitable[Any]]): Обработчик сообщения.
        event (Message): Объект сообщения от Telegram.
        data (Dict[str, Any]): Дополнительные данные.

    Returns:
        Any: Результат обработки сообщения обработчиком, если лимит не превышен.

    """
```

**Назначение**: Проверка и ограничение частоты запросов от пользователей.

**Параметры**:
- `handler` (Callable[[Message, Dict[str, Any]], Awaitable[Any]]): Обработчик сообщения.
- `event` (Message): Объект сообщения от Telegram.
- `data` (Dict[str, Any]): Дополнительные данные.

**Возвращает**:
- `Any`: Результат обработки сообщения обработчиком, если лимит не превышен.

**Как работает функция**:

1.  Проверяет, есть ли идентификатор чата (`event.chat.id`) в кэше `self.limit`.
2.  Если идентификатор чата уже есть в кэше, это означает, что пользователь недавно отправлял сообщение, и функция возвращает `None`, чтобы предотвратить дальнейшую обработку сообщения.
3.  Если идентификатора чата нет в кэше, функция добавляет его в кэш (`self.limit[event.chat.id] = None`) и вызывает обработчик сообщения (`await handler(event, data)`), чтобы продолжить обработку сообщения.

ASCII схема работы функции:

```
A: Получение сообщения
│
B: Проверка наличия chat.id в кэше
│
├── Нет ── C: Добавление chat.id в кэш → D: Вызов обработчика сообщения
│
└── Да ── E: Игнорирование сообщения
```

**Примеры**:

```python
# Пример использования ThrottlingMiddleware в aiogram
from aiogram import Bot, Dispatcher
from aiogram.types import Message
import asyncio
from typing import Any, Dict

# Инициализация бота и диспетчера
bot = Bot(token="YOUR_TELEGRAM_BOT_TOKEN")
dp = Dispatcher()

# Создание экземпляра ThrottlingMiddleware
throttling_middleware = ThrottlingMiddleware(time_limit=2)

# Регистрация middleware
dp.message.middleware(throttling_middleware)

# Обработчик сообщений
@dp.message()
async def echo(message: Message, data: Dict[str, Any]):
    await message.answer(f"You said: {message.text}")

# Запуск бота
async def main():
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
```
В этом примере, если пользователь отправит два сообщения в течение 2 секунд, второе сообщение будет проигнорировано.