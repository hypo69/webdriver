# Модуль `DDG.py`

## Обзор

Модуль `DDG.py` предоставляет асинхронный интерфейс для взаимодействия с чат-ботом DuckDuckGo AI. Он включает в себя функциональность для получения ответов от различных языковых моделей, таких как gpt-4o-mini, Llama-3.3-70B и Claude-3-Haiku. Модуль поддерживает потоковую передачу ответов, системные сообщения и сохранение истории сообщений.

## Подробней

Модуль `DDG.py` предназначен для интеграции в проекты, требующие взаимодействия с DuckDuckGo AI. Он автоматизирует процесс установления соединения, обработки запросов и получения ответов. Поддерживает обработку ошибок, таких как лимиты скорости и проблемы с подключением.

## Классы

### `DuckDuckGoSearchException`

**Описание**: Базовый класс исключений для модуля `duckduckgo_search`.

### `Conversation`

**Описание**: Класс для хранения истории сообщений и куки для поддержания контекста разговора.
**Наследует**: `JsonConversation`

**Атрибуты**:
- `vqd` (str): Токен VQD для текущей сессии.
- `vqd_hash_1` (str): Хэш VQD для текущей сессии.
- `message_history` (Messages): Список сообщений в истории разговора.
- `cookies` (dict): Словарь куки, используемых в сессии.
- `fe_version` (str): Версия frontend для запросов.

**Методы**:
- `__init__(self, model: str)`:
  Инициализирует объект `Conversation` с указанной моделью.

### `DDG`

**Описание**: Класс, реализующий асинхронного провайдера для взаимодействия с DuckDuckGo AI Chat.
**Наследует**: `AsyncGeneratorProvider`, `ProviderModelMixin`

**Атрибуты**:
- `label` (str): Метка провайдера ("DuckDuckGo AI Chat").
- `url` (str): URL главной страницы DuckDuckGo AI Chat ("https://duckduckgo.com/aichat").
- `api_endpoint` (str): URL API для отправки сообщений ("https://duckduckgo.com/duckchat/v1/chat").
- `status_url` (str): URL для получения статуса сессии ("https://duckduckgo.com/duckchat/v1/status").
- `working` (bool): Флаг, указывающий на работоспособность провайдера (True).
- `supports_stream` (bool): Флаг, указывающий на поддержку потоковой передачи (True).
- `supports_system_message` (bool): Флаг, указывающий на поддержку системных сообщений (True).
- `supports_message_history` (bool): Флаг, указывающий на поддержку истории сообщений (True).
- `default_model` (str): Модель, используемая по умолчанию ("gpt-4o-mini").
- `models` (List[str]): Список поддерживаемых моделей.
- `model_aliases` (dict): Словарь псевдонимов моделей.
- `last_request_time` (float): Время последнего запроса.
- `max_retries` (int): Максимальное количество попыток повтора запроса.
- `base_delay` (int): Базовая задержка между запросами в секундах.
- `_chat_xfe` (str): Классовая переменная для хранения версии x-fe.

**Методы**:
- `sha256_base64(text: str) -> str`:
  Возвращает base64-представление SHA256-хеша переданного текста.

- `parse_dom_fingerprint(js_text: str) -> str`:
  Извлекает отпечаток DOM из JavaScript кода.
  В случае неудачи возвращает "1000".

- `parse_server_hashes(js_text: str) -> list`:
  Извлекает серверные хеши из JavaScript кода.
  В случае неудачи возвращает `["1", "2"]`.

- `build_x_vqd_hash_1(cls, vqd_hash_1: str, headers: dict) -> str`:
  Строит значение заголовка `x-vqd-hash-1` на основе переданного хеша VQD и заголовков.

- `validate_model(cls, model: str) -> str`:
  Проверяет и возвращает корректное имя модели.

- `sleep(cls, multiplier=1.0)`:
  Реализует ограничение скорости запросов.

- `get_default_cookies(cls, session: ClientSession) -> dict`:
  Получает куки, необходимые для API-запросов.

- `fetch_fe_version(cls, session: ClientSession) -> str`:
  Извлекает версию fe из начальной загрузки страницы.

- `fetch_vqd_and_hash(cls, session: ClientSession, retry_count: int = 0) -> tuple[str, str]`:
  Получает токены VQD и хеш для чат-сессии с повторными попытками.

- `create_async_generator(...) -> AsyncResult`:
  Создает асинхронный генератор для получения ответов от DuckDuckGo AI Chat.

## Функции

### `sha256_base64`

```python
@staticmethod
def sha256_base64(text: str) -> str:
    """Return the base64 encoding of the SHA256 digest of the text."""
    ...
```

**Назначение**:
Возвращает base64-представление SHA256-хеша переданного текста.

**Параметры**:
- `text` (str): Текст для хеширования.

**Возвращает**:
- `str`: Base64-представление SHA256-хеша текста.

**Как работает функция**:
1. Кодирует входную строку `text` в байты, используя кодировку UTF-8.
2. Вычисляет SHA256-хеш полученных байтов.
3. Кодирует полученный хеш в формат base64.
4. Декодирует результат из байтов в строку UTF-8 и возвращает её.

**Примеры**:
```python
text = "Пример текста для хеширования"
result = DDG.sha256_base64(text)
print(result)  # Вывод: закодированный хеш
```

### `parse_dom_fingerprint`

```python
@staticmethod
def parse_dom_fingerprint(js_text: str) -> str:
    """Парсит HTML для извлечения отпечатка DOM."""
    ...
```

**Назначение**:
Извлекает отпечаток DOM из JavaScript кода.

**Параметры**:
- `js_text` (str): JavaScript код, содержащий HTML.

**Возвращает**:
- `str`: Отпечаток DOM в виде строки. В случае неудачи возвращает "1000".

**Как работает функция**:

**Внутренние функции**:

 - Отсутствуют

**ASCII flowchart**:

```
A [Проверка наличия BeautifulSoup]
|
B [Если BeautifulSoup отсутствует: Возврат "1000"]
|
C [Попытка извлечения HTML-фрагмента и значения смещения из js_text]
|
D [Создание объекта BeautifulSoup]
|
E [Извлечение внутреннего HTML из тела BeautifulSoup]
|
F [Вычисление длины внутреннего HTML]
|
G [Вычисление отпечатка как int(offset_value) + inner_html_length]
|
H [Возврат строкового представления отпечатка]
|
I [Если возникает исключение: Возврат "1000"]
```

1. Проверяет, установлен ли модуль `BeautifulSoup`. Если нет, возвращает `"1000"`.
2. Пытается извлечь HTML-фрагмент и значение смещения из переданного JavaScript кода.
3. Создает объект `BeautifulSoup` на основе извлеченного HTML-фрагмента.
4. Извлекает внутренний HTML из тела `BeautifulSoup`.
5. Вычисляет длину внутреннего HTML.
6. Вычисляет отпечаток DOM как сумму значения смещения и длины внутреннего HTML.
7. Возвращает отпечаток DOM в виде строки.
8. В случае возникновения исключения возвращает `"1000"`.

**Примеры**:
```python
js_code = "e.innerHTML = '<div id=\"test\">Пример</div>'; return String(123);"
result = DDG.parse_dom_fingerprint(js_code)
print(result)  # Вывод: отпечаток DOM или "1000"
```

### `parse_server_hashes`

```python
@staticmethod
def parse_server_hashes(js_text: str) -> list:
    """Парсит js для извлечения серверных хешей."""
    ...
```

**Назначение**:
Извлекает серверные хеши из JavaScript кода.

**Параметры**:
- `js_text` (str): JavaScript код, содержащий серверные хеши.

**Возвращает**:
- `list`: Список серверных хешей. В случае неудачи возвращает `["1", "2"]`.

**Как работает функция**:

**Внутренние функции**:

 - Отсутствуют

**ASCII flowchart**:

```
A [Попытка извлечения серверных хешей из js_text]
|
B [Разделение js_text для получения списка хешей]
|
C [Возврат списка хешей]
|
D [Если возникает исключение: Возврат ["1", "2"]]
```

1. Пытается извлечь серверные хеши из переданного JavaScript кода.
2. Разделяет текст для получения списка хешей.
3. Возвращает список серверных хешей.
4. В случае возникновения исключения возвращает `["1", "2"]`.

**Примеры**:
```python
js_code = 'server_hashes: ["hash1","hash2"]'
result = DDG.parse_server_hashes(js_code)
print(result)  # Вывод: список хешей или ["1", "2"]
```

### `build_x_vqd_hash_1`

```python
@classmethod
def build_x_vqd_hash_1(cls, vqd_hash_1: str, headers: dict) -> str:
    """Строит заголовок x-vqd-hash-1."""
    ...
```

**Назначение**:
Строит значение заголовка `x-vqd-hash-1` на основе переданного хеша VQD и заголовков.

**Параметры**:
- `vqd_hash_1` (str): Хеш VQD.
- `headers` (dict): Словарь заголовков запроса.

**Возвращает**:
- `str`: Значение заголовка `x-vqd-hash-1`. Если что-то пойдет не так, возвращает пустую строку.

**Как работает функция**:

**Внутренние функции**:

 - `parse_server_hashes(js_text: str) -> list`
  Извлекает серверные хеши из JavaScript кода.
  В случае неудачи возвращает `["1", "2"]`.

 - `parse_dom_fingerprint(js_text: str) -> str`
  Извлекает отпечаток DOM из JavaScript кода.
  В случае неудачи возвращает "1000".

 - `sha256_base64(text: str) -> str`
  Возвращает base64-представление SHA256-хеша переданного текста.

**ASCII flowchart**:

```
A [Декодирование vqd_hash_1 из base64]
|
B [Извлечение серверных хешей с помощью parse_server_hashes]
|
C [Извлечение отпечатка DOM с помощью parse_dom_fingerprint]
|
D [Создание fingerprint пользовательского агента]
|
E [Создание хеша пользовательского агента с помощью sha256_base64]
|
F [Создание хеша DOM с помощью sha256_base64]
|
G [Создание JSON структуры с хешами сервера, клиента и сигналами]
|
H [Кодирование JSON структуры в base64]
|
I [Возврат закодированной строки]
|
J [Если возникает исключение: Возврат ""]
```

1. Декодирует `vqd_hash_1` из base64.
2. Извлекает серверные хеши из декодированной строки.
3. Извлекает отпечаток DOM из декодированной строки.
4. Формирует fingerprint пользовательского агента на основе заголовков.
5. Вычисляет хеш пользовательского агента.
6. Вычисляет хеш отпечатка DOM.
7. Формирует JSON структуру, содержащую хеши сервера, клиента и сигналы.
8. Кодирует JSON структуру в base64.
9. Возвращает закодированную строку.
10. В случае возникновения исключения возвращает пустую строку.

**Примеры**:
```python
vqd_hash = "some_vqd_hash"
headers = {"User-Agent": "Mozilla/5.0", "sec-ch-ua": '"Chromium";v="133"'}
result = DDG.build_x_vqd_hash_1(vqd_hash, headers)
print(result)  # Вывод: сгенерированный заголовок или ""
```

### `validate_model`

```python
@classmethod
def validate_model(cls, model: str) -> str:
    """Проверяет и возвращает корректное имя модели."""
    ...
```

**Назначение**:
Проверяет и возвращает корректное имя модели.

**Параметры**:
- `model` (str): Имя модели для проверки.

**Возвращает**:
- `str`: Корректное имя модели.

**Вызывает исключения**:
- `ModelNotSupportedError`: Если указанная модель не поддерживается.

**Как работает функция**:

**Внутренние функции**:

 - Отсутствуют

**ASCII flowchart**:

```
A [Проверка, что model не пустая строка]
|
B [Если model пустая: возврат cls.default_model]
|
C [Проверка наличия model в model_aliases]
|
D [Если model в model_aliases: замена model на alias]
|
E [Проверка наличия model в cls.models]
|
F [Если model нет в cls.models: вызов ModelNotSupportedError]
|
G [Возврат model]
```

1. Проверяет, является ли входная модель пустой строкой. Если да, возвращает модель по умолчанию.
2. Проверяет, есть ли псевдоним для указанной модели в словаре `model_aliases`.
3. Если псевдоним существует, заменяет имя модели на псевдоним.
4. Проверяет, поддерживается ли модель (есть ли она в списке `cls.models`).
5. Если модель не поддерживается, вызывает исключение `ModelNotSupportedError`.
6. Возвращает имя проверенной модели.

**Примеры**:
```python
model = "gpt-4"
result = DDG.validate_model(model)
print(result)  # Вывод: gpt-4o-mini

model = "unsupported_model"
try:
    DDG.validate_model(model)
except ModelNotSupportedError as ex:
    print(ex)  # Вывод: Model unsupported_model not supported. Available models: ...
```

### `sleep`

```python
@classmethod
async def sleep(cls, multiplier=1.0):
    """Ограничивает скорость запросов."""
    ...
```

**Назначение**:
Реализует ограничение скорости запросов между запросами к API.

**Параметры**:
- `multiplier` (float, optional): Множитель задержки. По умолчанию `1.0`.

**Как работает функция**:

**Внутренние функции**:

 - Отсутствуют

**ASCII flowchart**:

```
A [Получение текущего времени]
|
B [Проверка, было ли время последнего запроса установлено]
|
C [Если время последнего запроса > 0: вычисление задержки]
|
D [Если задержка > 0: ожидание в течение вычисленной задержки]
|
E [Обновление времени последнего запроса]
```

1. Получает текущее время.
2. Проверяет, было ли установлено время последнего запроса.
3. Если время последнего запроса установлено, вычисляет задержку на основе времени последнего запроса и множителя.
4. Если задержка больше нуля, ожидает в течение вычисленной задержки.
5. Обновляет время последнего запроса текущим временем.

**Примеры**:
```python
await DDG.sleep()  # Ожидание с множителем по умолчанию
await DDG.sleep(multiplier=2.0)  # Ожидание с удвоенной задержкой
```

### `get_default_cookies`

```python
@classmethod
async def get_default_cookies(cls, session: ClientSession) -> dict:
    """Получает дефолтные куки."""
    ...
```

**Назначение**:
Получает куки, необходимые для API-запросов.

**Параметры**:
- `session` (ClientSession): Асинхронная сессия для выполнения HTTP-запросов.

**Возвращает**:
- `dict`: Словарь с куки.

**Вызывает исключения**:
- `Exception`: В случае ошибки при выполнении запроса.

**Как работает функция**:

**Внутренние функции**:

 - Отсутствуют

**ASCII flowchart**:

```
A [Ожидание с помощью sleep]
|
B [Выполнение GET-запроса к cls.url]
|
C [Создание словаря cookies]
|
D [Установка cookies в session.cookie_jar]
|
E [Возврат словаря cookies]
|
F [В случае исключения: возврат {}]
```

1. Ожидает с помощью `cls.sleep()` для соблюдения лимитов скорости.
2. Выполняет GET-запрос к `cls.url` для получения куки.
3. Создает словарь с необходимыми куки (`'dcs': '1'`, `'dcm': '3'`).
4. Устанавливает полученные куки в `session.cookie_jar`.
5. Возвращает словарь с куки.
6. В случае возникновения исключения возвращает пустой словарь.

**Примеры**:
```python
import asyncio
from aiohttp import ClientSession

async def main():
    async with ClientSession() as session:
        cookies = await DDG.get_default_cookies(session)
        print(cookies)

asyncio.run(main())
```

### `fetch_fe_version`

```python
@classmethod
async def fetch_fe_version(cls, session: ClientSession) -> str:
    """Извлекает версию fe из ответа."""
    ...
```

**Назначение**:
Извлекает версию `fe` из начальной загрузки страницы.

**Параметры**:
- `session` (ClientSession): Асинхронная сессия для выполнения HTTP-запросов.

**Возвращает**:
- `str`: Версия `fe`. Если извлечение не удалось, возвращает пустую строку.

**Как работает функция**:

**Внутренние функции**:

 - Отсутствуют

**ASCII flowchart**:

```
A [Проверка, установлена ли версия в cls._chat_xfe]
|
B [Если установлена: возврат cls._chat_xfe]
|
C [Выполнение GET-запроса к URL]
|
D [Извлечение xfe1 и xfe2 из контента ответа]
|
E [Формирование cls._chat_xfe = f"{xfe1}-{xfe2}"]
|
F [Возврат cls._chat_xfe]
|
G [Если извлечение не удалось: возврат ""]
|
H [В случае исключения: возврат ""]
```

1. Проверяет, установлена ли версия `fe` в классовой переменной `cls._chat_xfe`. Если да, возвращает это значение.
2. Выполняет GET-запрос к URL для получения содержимого страницы.
3. Извлекает компоненты версии `fe` (`xfe1` и `xfe2`) из содержимого ответа.
4. Формирует версию `fe` как строку `f"{xfe1}-{xfe2}"` и сохраняет её в `cls._chat_xfe`.
5. Возвращает версию `fe`.
6. Если извлечение не удалось, возвращает пустую строку.
7. В случае возникновения исключения возвращает пустую строку.

**Примеры**:
```python
import asyncio
from aiohttp import ClientSession

async def main():
    async with ClientSession() as session:
        fe_version = await DDG.fetch_fe_version(session)
        print(fe_version)

asyncio.run(main())
```

### `fetch_vqd_and_hash`

```python
@classmethod
async def fetch_vqd_and_hash(cls, session: ClientSession, retry_count: int = 0) -> tuple[str, str]:
    """Получает VQD токен и хеш."""
    ...
```

**Назначение**:
Получает токены VQD и хеш для чат-сессии с повторными попытками.

**Параметры**:
- `session` (ClientSession): Асинхронная сессия для выполнения HTTP-запросов.
- `retry_count` (int, optional): Количество попыток повтора. По умолчанию `0`.

**Возвращает**:
- `tuple[str, str]`: Кортеж, содержащий VQD токен и хеш.

**Вызывает исключения**:
- `RuntimeError`: Если не удается получить VQD токен и хеш после нескольких попыток.

**Как работает функция**:

**Внутренние функции**:

 - Отсутствуют

**ASCII flowchart**:

```
A [Проверка наличия cookies]
|
B [Если cookies отсутствуют: получение default cookies]
|
C [Ожидание с помощью sleep]
|
D [Выполнение GET-запроса к status_url]
|
E [Извлечение vqd и vqd_hash_1 из заголовков ответа]
|
F [Если vqd получен: возврат vqd и vqd_hash_1]
|
G [Если vqd не получен: проверка retry_count]
|
H [Если retry_count < max_retries: ожидание и рекурсивный вызов fetch_vqd_and_hash]
|
I [Если retry_count >= max_retries: вызов RuntimeError]
|
J [В случае исключения: проверка retry_count и повторные попытки или вызов RuntimeError]
```

1. Проверяет, установлены ли куки в сессии. Если нет, получает куки по умолчанию.
2. Ожидает с помощью `cls.sleep()` для соблюдения лимитов скорости.
3. Выполняет GET-запрос к `cls.status_url` для получения VQD токена и хеша.
4. Извлекает VQD токен и хеш из заголовков ответа.
5. Если VQD токен получен, возвращает его вместе с хешем.
6. Если VQD токен не получен, проверяет количество попыток повтора.
7. Если количество попыток меньше максимального, ожидает некоторое время и рекурсивно вызывает `fetch_vqd_and_hash` с увеличенным счетчиком попыток.
8. Если количество попыток достигло максимального, вызывает исключение `RuntimeError`.
9. В случае возникновения исключения, проверяет количество попыток повтора и либо повторяет попытку, либо вызывает исключение `RuntimeError`.

**Примеры**:
```python
import asyncio
from aiohttp import ClientSession

async def main():
    async with ClientSession() as session:
        vqd, vqd_hash_1 = await DDG.fetch_vqd_and_hash(session)
        print(f"VQD: {vqd}, Hash: {vqd_hash_1}")

asyncio.run(main())
```

### `create_async_generator`

```python
@classmethod
async def create_async_generator(
    cls,
    model: str,
    messages: Messages,
    proxy: str = None,
    timeout: int = 60,
    cookies: Cookies = None,
    conversation: Conversation = None,
    return_conversation: bool = False,
    **kwargs
) -> AsyncResult:
    """Создает асинхронный генератор для получения ответов."""
    ...
```

**Назначение**:
Создает асинхронный генератор для получения ответов от DuckDuckGo AI Chat.

**Параметры**:
- `model` (str): Имя языковой модели.
- `messages` (Messages): Список сообщений для отправки.
- `proxy` (str, optional): URL прокси-сервера. По умолчанию `None`.
- `timeout` (int, optional): Время ожидания запроса в секундах. По умолчанию `60`.
- `cookies` (Cookies, optional): Куки для использования в сессии. По умолчанию `None`.
- `conversation` (Conversation, optional): Объект `Conversation` для поддержания контекста. По умолчанию `None`.
- `return_conversation` (bool, optional): Флаг, указывающий, нужно ли возвращать объект `Conversation`. По умолчанию `False`.
- `**kwargs`: Дополнительные параметры.

**Возвращает**:
- `AsyncResult`: Асинхронный генератор для получения ответов.

**Вызывает исключения**:
- `ModelNotSupportedError`: Если указанная модель не поддерживается.
- `RateLimitError`: Если превышен лимит запросов.
- `TimeoutError`: Если запрос превысил время ожидания.
- `Exception`: В случае других ошибок.

**Как работает функция**:

**Внутренние функции**:

 - Отсутствуют

**ASCII flowchart**:

```
A [Валидация модели]
|
B [Цикл повторных попыток]
|
C [Создание асинхронной сессии]
|
D [Получение fe_version, если не установлена]
|
E [Инициализация/обновление conversation]
|
F [Получение VQD токенов]
|
G [Подготовка заголовков]
|
H [Подготовка данных запроса]
|
I [Отправка POST-запроса]
|
J [Обработка ошибок 429]
|
K [Обработка потокового ответа]
|
L [Обновление conversation с информацией об ответе]
|
M [Возврат conversation, если return_conversation == True]
|
N [Обработка RateLimitError и ResponseStatusError]
|
O [Обработка TimeoutError]
|
P [Обработка остальных исключений]
```

1. Валидирует имя модели с помощью `cls.validate_model()`.
2. Инициализирует счетчик повторных попыток.
3. Входит в цикл повторных попыток, пока счетчик не превысит `cls.max_retries`.
4. Создает асинхронную сессию с заданным таймаутом и куками.
5. Получает версию `fe`, если она еще не установлена.
6. Инициализирует или обновляет объект `Conversation`.
7. Получает токены VQD с помощью `cls.fetch_vqd_and_hash()`.
8. Подготавливает заголовки запроса, включая токены VQD и версию `fe`.
9. Подготавливает данные запроса, включая модель и историю сообщений.
10. Отправляет POST-запрос к `cls.api_endpoint` с подготовленными данными и заголовками.
11. Обрабатывает ошибки 429 (превышение лимита запросов) с повторными попытками.
12. Обрабатывает потоковый ответ, извлекая сообщения и обновляя контекст.
13. Обновляет объект `Conversation` с информацией об ответе, если `return_conversation` равен `True`.
14. Возвращает объект `Conversation`, если `return_conversation` равен `True`.
15. Обрабатывает исключения `RateLimitError` и `ResponseStatusError`.
16. Обрабатывает исключение `TimeoutError`.
17. Обрабатывает все остальные исключения.

**Примеры**:
```python
import asyncio
from aiohttp import ClientSession
from typing import List, Dict

async def main():
    model = "gpt-4o-mini"
    messages: List[Dict[str, str]] = [{"role": "user", "content": "Привет, как дела?"}]

    async for response in DDG.create_async_generator(model=model, messages=messages):
        print(response)

asyncio.run(main())