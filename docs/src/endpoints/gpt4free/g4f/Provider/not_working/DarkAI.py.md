# Модуль `DarkAI`

## Обзор

Модуль `DarkAI` предоставляет асинхронный класс `DarkAI`, который реализует взаимодействие с сервисом `darkai.foundation` для генерации текста на основе предоставленных сообщений. Он поддерживает потоковую передачу данных и использует различные модели, такие как `gpt-4o`, `gpt-3.5-turbo` и `llama-3-70b`. Этот модуль предназначен для использования в асинхронных приложениях, требующих генерацию текста в реальном времени.

## Подробней

Модуль `DarkAI` является частью проекта `hypotez` и предназначен для интеграции с AI-провайдером `darkai.foundation`. Он обеспечивает асинхронное взаимодействие с API `darkai.foundation`, позволяя генерировать текст на основе предоставленных сообщений. Модуль поддерживает потоковую передачу данных, что позволяет получать результаты генерации текста в реальном времени.

## Классы

### `DarkAI`

**Описание**: Класс `DarkAI` предоставляет методы для взаимодействия с API `darkai.foundation` для генерации текста на основе предоставленных сообщений.

**Наследует**:
- `AsyncGeneratorProvider`: Обеспечивает асинхронную генерацию данных.
- `ProviderModelMixin`: Предоставляет функциональность для работы с моделями.

**Аттрибуты**:
- `url` (str): URL сервиса `darkai.foundation`.
- `api_endpoint` (str): URL API `darkai.foundation`.
- `working` (bool): Флаг, указывающий, работает ли провайдер.
- `supports_stream` (bool): Флаг, указывающий, поддерживает ли провайдер потоковую передачу данных.
- `default_model` (str): Модель, используемая по умолчанию (`llama-3-70b`).
- `models` (List[str]): Список поддерживаемых моделей (`gpt-4o`, `gpt-3.5-turbo`, `llama-3-70b`).
- `model_aliases` (Dict[str, str]): Словарь псевдонимов моделей.

**Методы**:
- `create_async_generator`: Создает асинхронный генератор для получения сгенерированного текста.

## Функции

### `create_async_generator`

```python
@classmethod
async def create_async_generator(
    cls,
    model: str,
    messages: Messages,
    proxy: str = None,
    **kwargs
) -> AsyncResult:
    """
    Создает асинхронный генератор для получения сгенерированного текста от API `darkai.foundation`.

    Args:
        model (str): Название модели для использования.
        messages (Messages): Список сообщений для отправки в API.
        proxy (str, optional): Прокси-сервер для использования. По умолчанию `None`.
        **kwargs: Дополнительные аргументы.

    Returns:
        AsyncResult: Асинхронный генератор, возвращающий сгенерированный текст.

    Raises:
        Exception: Если возникает ошибка при взаимодействии с API.
    """
```

**Назначение**: Функция `create_async_generator` создает асинхронный генератор, который отправляет запросы к API `darkai.foundation` и возвращает сгенерированный текст. Она отвечает за форматирование запроса, отправку его на API и обработку потоковых данных.

**Параметры**:
- `cls` (DarkAI): Ссылка на класс `DarkAI`.
- `model` (str): Название модели для использования.
- `messages` (Messages): Список сообщений для отправки в API.
- `proxy` (str, optional): Прокси-сервер для использования. По умолчанию `None`.
- `**kwargs`: Дополнительные аргументы.

**Возвращает**:
- `AsyncResult`: Асинхронный генератор, возвращающий сгенерированный текст.

**Вызывает исключения**:
- `Exception`: Если возникает ошибка при взаимодействии с API.

**Как работает функция**:

1. **Получение модели**: Извлекает название модели, используя `cls.get_model(model)`.
2. **Формирование заголовков**: Создает заголовки запроса, включая `accept`, `content-type` и `user-agent`.
3. **Создание сессии**: Инициализирует асинхронную сессию `ClientSession` с заданными заголовками и таймаутом.
4. **Форматирование промпта**: Преобразует список сообщений в формат, требуемый API, используя `format_prompt(messages)`.
5. **Формирование данных**: Создает словарь с данными запроса, содержащий `query` (сформатированный промпт) и `model` (название модели).
6. **Отправка запроса**: Отправляет POST-запрос к API `cls.api_endpoint` с данными в формате JSON и прокси-сервером (если указан).
7. **Обработка ответа**:
    - Проверяет статус ответа с помощью `raise_for_status(response)`.
    - Читает данные из потока ответа чанками по 1024 байта.
    - Накапливает чанки в буфере.
    - Разделяет буфер по символу новой строки (`\n`).
    - Обрабатывает каждую строку:
        - Удаляет пробелы в начале и конце строки.
        - Проверяет, начинается ли строка с `data: `.
        - Извлекает JSON-данные из строки.
        - Если `event` равен `text-chunk`, извлекает текст и возвращает его через `yield`.
        - Если `event` равен `stream-end`, завершает работу генератора.
    - Обрабатывает исключения `json.JSONDecodeError` и `Exception` при разборе JSON-данных.

8. **Завершение**: После завершения чтения потока ответа, генератор завершает свою работу.

```
A: Получение модели
|
B: Формирование заголовков
|
C: Создание асинхронной сессии
|
D: Форматирование промпта
|
E: Формирование данных
|
F: Отправка POST-запроса к API
|
G: Обработка ответа
|
H: Чтение данных из потока ответа чанками
|
I: Разделение буфера по символу новой строки
|
J: Обработка каждой строки
|
K: Извлечение JSON-данных из строки
|
L: Проверка event (text-chunk или stream-end)
|
M: Возврат текста через yield или завершение генератора
```

**Примеры**:

```python
# Пример использования create_async_generator
import asyncio
from typing import AsyncGenerator, List, Dict, Any

from src.endpoints.gpt4free.g4f.Provider.not_working.DarkAI import DarkAI

async def main():
    model = "gpt-4o"
    messages = [{"role": "user", "content": "Привет, как дела?"}]
    proxy = None

    async def consume_generator(generator: AsyncGenerator[str, None]) -> str:
        full_text = ""
        async for chunk in generator:
            full_text += chunk
        return full_text

    generator = DarkAI.create_async_generator(model=model, messages=messages, proxy=proxy)
    if isinstance(generator, AsyncGenerator):
        result = await consume_generator(generator)
        print(f"Результат: {result}")
    else:
        print("Ошибка: Не удалось создать асинхронный генератор.")

if __name__ == "__main__":
    asyncio.run(main())