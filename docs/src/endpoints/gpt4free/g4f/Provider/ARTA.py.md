# Модуль для работы с ARTA API
## Обзор

Модуль `ARTA` предоставляет асинхронный интерфейс для взаимодействия с API ARTA, предназначенным для генерации изображений на основе текстовых запросов. Он включает в себя функциональность для аутентификации, запроса генерации изображений и проверки статуса генерации.

## Подробней

Модуль содержит класс `ARTA`, который наследует от `AsyncGeneratorProvider` и `ProviderModelMixin`. Этот класс реализует методы для аутентификации, обновления токена, запроса генерации изображений и проверки статуса генерации. Модуль предназначен для использования в асинхронных приложениях, где требуется генерация изображений на основе текстовых запросов.

## Классы

### `ARTA`

**Описание**: Класс `ARTA` предоставляет методы для взаимодействия с API ARTA для генерации изображений.

**Наследует**:
- `AsyncGeneratorProvider`: Обеспечивает поддержку асинхронных генераторов.
- `ProviderModelMixin`: Предоставляет общие методы для работы с моделями.

**Атрибуты**:
- `url` (str): Базовый URL API ARTA.
- `auth_url` (str): URL для аутентификации.
- `token_refresh_url` (str): URL для обновления токена.
- `image_generation_url` (str): URL для запроса генерации изображений.
- `status_check_url` (str): URL для проверки статуса генерации.
- `working` (bool): Флаг, указывающий, работает ли провайдер.
- `default_model` (str): Модель, используемая по умолчанию.
- `default_image_model` (str): Модель для генерации изображений, используемая по умолчанию.
- `model_aliases` (dict): Словарь псевдонимов моделей.
- `image_models` (list): Список поддерживаемых моделей для генерации изображений.
- `models` (list): Список всех доступных моделей.

**Методы**:
- `get_auth_file()`: Возвращает путь к файлу аутентификации.
- `create_token(path: Path, proxy: str | None = None)`: Создает токен аутентификации.
- `refresh_token(refresh_token: str, proxy: str | None = None)`: Обновляет токен аутентификации.
- `read_and_refresh_token(proxy: str | None = None)`: Читает токен из файла и обновляет его при необходимости.
- `create_async_generator(model: str, messages: Messages, proxy: str | None = None, prompt: str | None = None, negative_prompt: str = "blurry, deformed hands, ugly", n: int = 1, guidance_scale: int = 7, num_inference_steps: int = 30, aspect_ratio: str = "1:1", seed: int = None, **kwargs)`: Создает асинхронный генератор для генерации изображений.

## Функции

### `get_auth_file`

```python
    @classmethod
    def get_auth_file(cls) -> Path:
        """
        Возвращает путь к файлу аутентификации.

        Returns:
            Path: Путь к файлу аутентификации.

        Как работает функция:
        1. Получает директорию для хранения cookies.
        2. Создает директорию, если она не существует.
        3. Формирует имя файла аутентификации на основе имени класса.
        4. Возвращает объект Path, представляющий путь к файлу аутентификации.
        """
```

**Назначение**: Получение пути к файлу, где хранится информация об аутентификации.

**Возвращает**:
- `Path`: Объект `Path`, представляющий путь к файлу аутентификации.

**Как работает функция**:

     A
     ↓
     B
     ↓
     C
     ↓
     D

Где:
- `A`: Получение директории для хранения cookies (`get_cookies_dir()`).
- `B`: Создание директории, если она не существует (`path.mkdir(exist_ok=True)`).
- `C`: Формирование имени файла аутентификации на основе имени класса.
- `D`: Возврат объекта `Path`, представляющего путь к файлу аутентификации.

**Примеры**:
```python
# Пример использования функции get_auth_file
path = ARTA.get_auth_file()
print(path)  # Вывод: /путь/к/cookies/auth_ARTA.json
```

### `create_token`

```python
    @classmethod
    async def create_token(cls, path: Path, proxy: str | None = None) -> dict:
        """
        Создает токен аутентификации.

        Args:
            path (Path): Путь для сохранения данных аутентификации.
            proxy (str | None, optional): URL прокси-сервера. По умолчанию None.

        Returns:
            dict: Данные аутентификации.

        Raises:
            ResponseError: Если не удается получить токен аутентификации.
        """
```

**Назначение**: Генерация токена аутентификации для доступа к API ARTA.

**Параметры**:
- `path` (`Path`): Путь к файлу, в котором будут сохранены данные аутентификации.
- `proxy` (`str | None`, optional): URL прокси-сервера, если требуется его использование. По умолчанию `None`.

**Возвращает**:
- `dict`: Данные аутентификации, содержащие токен.

**Вызывает исключения**:
- `ResponseError`: Если не удается получить токен аутентификации.

**Как работает функция**:
1.  **Инициализация сессии**: Создается асинхронная сессия клиента для выполнения HTTP-запросов.
2.  **Формирование полезной нагрузки (payload)**: Определяется полезная нагрузка для запроса аутентификации, включающая тип клиента (`CLIENT_TYPE_ANDROID`).
3.  **Запрос аутентификации**: Выполняется POST-запрос к `cls.auth_url` с полезной нагрузкой и, при необходимости, через прокси-сервер.
4.  **Обработка ответа**: Извлекается токен аутентификации (`idToken`) из полученных данных.
5.  **Сохранение данных**: Если токен отсутствует, вызывается исключение `ResponseError`. В противном случае, данные аутентификации сохраняются в файл, указанный в `path`.

```
     A
     │
     B
     │
     C
     │
     D
     │
     E
     │
     F
```

Где:
- `A`: Инициализация асинхронной сессии (`ClientSession()`).
- `B`: Определение полезной нагрузки для запроса аутентификации (`auth_payload`).
- `C`: Выполнение POST-запроса к `cls.auth_url` с использованием сессии и полезной нагрузки.
- `D`: Извлечение данных аутентификации из ответа (`auth_response.json()`).
- `E`: Проверка наличия токена аутентификации (`auth_token`).
- `F`: Сохранение данных аутентификации в файл (`json.dump()`).

**Примеры**:

```python
from pathlib import Path
import asyncio

async def main():
    path = Path("auth_test.json")  # Укажите путь к файлу для сохранения данных
    token_data = await ARTA.create_token(path)
    print(token_data)

if __name__ == "__main__":
    asyncio.run(main())
```

### `refresh_token`

```python
    @classmethod
    async def refresh_token(cls, refresh_token: str, proxy: str | None = None) -> tuple[str, str]:
        """
        Обновляет токен аутентификации.

        Args:
            refresh_token (str): Токен для обновления.
            proxy (str | None, optional): URL прокси-сервера. По умолчанию None.

        Returns:
            tuple[str, str]: Новый токен и токен обновления.
        """
```

**Назначение**: Обновление токена аутентификации с использованием refresh token.

**Параметры**:
- `refresh_token` (`str`): Токен обновления, используемый для получения нового токена.
- `proxy` (`str | None`, optional): URL прокси-сервера, если требуется его использование. По умолчанию `None`.

**Возвращает**:
- `tuple[str, str]`: Кортеж, содержащий новый токен доступа и новый токен обновления.

**Как работает функция**:
1.  **Инициализация сессии**: Создается асинхронная сессия клиента для выполнения HTTP-запросов.
2.  **Формирование полезной нагрузки (payload)**: Определяется полезная нагрузка для запроса обновления токена, включающая тип запроса (`grant_type`) и сам `refresh_token`.
3.  **Запрос обновления токена**: Выполняется POST-запрос к `cls.token_refresh_url` с полезной нагрузкой и, при необходимости, через прокси-сервер.
4.  **Обработка ответа**: Извлекаются новый токен доступа (`id_token`) и новый `refresh_token` из полученных данных.
5.  **Возврат токенов**: Возвращается кортеж с новым токеном доступа и токеном обновления.

```
     A
     │
     B
     │
     C
     │
     D
     │
     E
```

Где:
- `A`: Инициализация асинхронной сессии (`ClientSession()`).
- `B`: Определение полезной нагрузки для запроса обновления токена (`payload`).
- `C`: Выполнение POST-запроса к `cls.token_refresh_url` с использованием сессии и полезной нагрузки.
- `D`: Извлечение данных из ответа (`response.json()`).
- `E`: Возврат нового токена доступа и токена обновления.

**Примеры**:

```python
import asyncio

async def main():
    refresh_token = "old_refresh_token"  # Замените на ваш refresh token
    new_token, new_refresh_token = await ARTA.refresh_token(refresh_token)
    print(f"New token: {new_token}")
    print(f"New refresh token: {new_refresh_token}")

if __name__ == "__main__":
    asyncio.run(main())
```

### `read_and_refresh_token`

```python
    @classmethod
    async def read_and_refresh_token(cls, proxy: str | None = None) -> dict:
        """
        Читает токен из файла и обновляет его при необходимости.

        Args:
            proxy (str | None, optional): URL прокси-сервера. По умолчанию None.

        Returns:
            dict: Данные аутентификации.
        """
```

**Назначение**: Чтение токена аутентификации из файла и его обновление, если срок действия истек или подходит к концу.

**Параметры**:
- `proxy` (`str | None`, optional): URL прокси-сервера, если требуется его использование. По умолчанию `None`.

**Возвращает**:
- `dict`: Данные аутентификации, содержащие токен.

**Как работает функция**:
1.  **Получение пути к файлу**: Получает путь к файлу, в котором хранятся данные аутентификации, с использованием метода `cls.get_auth_file()`.
2.  **Проверка существования файла**: Проверяет, существует ли файл с данными аутентификации.
3.  **Чтение данных из файла**: Если файл существует, читает данные аутентификации из файла.
4.  **Проверка срока действия токена**: Вычисляет разницу между текущим временем и временем изменения файла, а также сравнивает эту разницу со сроком действия токена.
5.  **Обновление токена (при необходимости)**: Если срок действия токена истек или подходит к концу (разница больше половины срока действия), выполняет обновление токена с использованием метода `cls.refresh_token()`.
6.  **Сохранение обновленных данных**: Если токен был обновлен, сохраняет обновленные данные аутентификации в файл.
7.  **Возврат данных аутентификации**: Возвращает данные аутентификации (обновленные или прочитанные из файла).
8.  **Создание токена (если файл не существует)**: Если файл с данными аутентификации не существует, создает новый токен с использованием метода `cls.create_token()`.

```
     A
     │
     B
     │
     C
     │
     D
     │
     E
     │
     F
     │
     G
```

Где:
- `A`: Получение пути к файлу (`cls.get_auth_file()`).
- `B`: Проверка существования файла (`path.is_file()`).
- `C`: Чтение данных из файла (`json.load()`).
- `D`: Проверка срока действия токена.
- `E`: Обновление токена (при необходимости) (`cls.refresh_token()`).
- `F`: Сохранение обновленных данных (при необходимости) (`json.dump()`).
- `G`: Возврат данных аутентификации.

**Примеры**:

```python
import asyncio

async def main():
    auth_data = await ARTA.read_and_refresh_token()
    print(auth_data)

if __name__ == "__main__":
    asyncio.run(main())
```

### `create_async_generator`

```python
    @classmethod
    async def create_async_generator(
        cls,
        model: str,
        messages: Messages,
        proxy: str = None,
        prompt: str = None,
        negative_prompt: str = "blurry, deformed hands, ugly",
        n: int = 1,
        guidance_scale: int = 7,
        num_inference_steps: int = 30,
        aspect_ratio: str = "1:1",
        seed: int = None,
        **kwargs
    ) -> AsyncResult:
        """
        Создает асинхронный генератор для генерации изображений.

        Args:
            model (str): Модель для генерации изображений.
            messages (Messages): Сообщения для генерации изображения.
            proxy (str, optional): URL прокси-сервера. По умолчанию None.
            prompt (str, optional): Текст запроса. По умолчанию None.
            negative_prompt (str, optional): Негативный текст запроса. По умолчанию "blurry, deformed hands, ugly".
            n (int, optional): Количество изображений для генерации. По умолчанию 1.
            guidance_scale (int, optional): Масштаб соответствия запросу. По умолчанию 7.
            num_inference_steps (int, optional): Количество шагов для генерации изображения. По умолчанию 30.
            aspect_ratio (str, optional): Соотношение сторон изображения. По умолчанию "1:1".
            seed (int, optional): Зерно для генерации случайных чисел. По умолчанию None.
            **kwargs: Дополнительные параметры.

        Yields:
            Reasoning: Информация о статусе генерации.
            ImageResponse: Сгенерированные изображения.

        Raises:
            ResponseError: Если не удается инициировать генерацию изображения или если генерация завершилась с ошибкой.
        """
```

**Назначение**: Создание асинхронного генератора для генерации изображений на основе текстового запроса.

**Параметры**:
- `model` (`str`): Модель для генерации изображений.
- `messages` (`Messages`): Список сообщений, используемых для формирования запроса.
- `proxy` (`str`, optional): URL прокси-сервера, если требуется его использование. По умолчанию `None`.
- `prompt` (`str`, optional): Текст запроса для генерации изображения. По умолчанию `None`.
- `negative_prompt` (`str`, optional): Негативный текст запроса, описывающий то, что не должно быть на изображении. По умолчанию `"blurry, deformed hands, ugly"`.
- `n` (`int`, optional): Количество изображений для генерации. По умолчанию `1`.
- `guidance_scale` (`int`, optional): Масштаб соответствия запросу. По умолчанию `7`.
- `num_inference_steps` (`int`, optional): Количество шагов для генерации изображения. По умолчанию `30`.
- `aspect_ratio` (`str`, optional): Соотношение сторон изображения. По умолчанию `"1:1"`.
- `seed` (`int`, optional): Зерно для генерации случайных чисел. По умолчанию `None`.
- `**kwargs`: Дополнительные параметры.

**Возвращает**:
- `AsyncResult`: Асинхронный генератор, который выдает объекты `Reasoning` и `ImageResponse`.

**Вызывает исключения**:
- `ResponseError`: Если не удается инициировать генерацию изображения или если генерация завершилась с ошибкой.

**Как работает функция**:
1.  **Выбор модели**: Получает выбранную модель для генерации изображений с использованием `cls.get_model(model)`.
2.  **Формирование запроса**: Формирует текстовый запрос на основе сообщений и текста запроса с использованием `format_image_prompt(messages, prompt)`.
3.  **Генерация случайного зерна**: Если зерно не предоставлено, генерирует случайное зерно для генерации изображений.
4.  **Аутентификация**: Получает токен аутентификации с использованием `cls.read_and_refresh_token(proxy)`.
5.  **Инициализация сессии**: Создает асинхронную сессию клиента для выполнения HTTP-запросов.
6.  **Формирование полезной нагрузки (payload)**: Определяет полезную нагрузку для запроса генерации изображения, включающую текст запроса, негативный текст запроса, модель, количество изображений, масштаб соответствия запросу, количество шагов и соотношение сторон.
7.  **Запрос генерации изображения**: Выполняется POST-запрос к `cls.image_generation_url` с полезной нагрузкой, заголовками аутентификации и, при необходимости, через прокси-сервер.
8.  **Обработка ответа**: Извлекается идентификатор записи (`record_id`) из полученных данных.
9.  **Проверка статуса генерации**: Периодически проверяет статус генерации изображения, отправляя GET-запросы к `cls.status_check_url`.
10. **Обработка статуса**:
    *   Если статус `DONE`, извлекает URL-адреса сгенерированных изображений и выдает объекты `Reasoning` и `ImageResponse`.
    *   Если статус `IN_QUEUE` или `IN_PROGRESS`, выдает объект `Reasoning` с информацией о статусе и ждет 2 секунды перед следующей проверкой.
    *   Если статус отличается от ожидаемых, вызывает исключение `ResponseError`.

```
     A
     │
     B
     │
     C
     │
     D
     │
     E
     │
     F
     │
     G
     │
     H
     │
     I
     │
     J
```

Где:
- `A`: Выбор модели (`cls.get_model(model)`).
- `B`: Формирование запроса (`format_image_prompt(messages, prompt)`).
- `C`: Генерация случайного зерна.
- `D`: Аутентификация (`cls.read_and_refresh_token(proxy)`).
- `E`: Инициализация асинхронной сессии (`ClientSession()`).
- `F`: Формирование полезной нагрузки (`image_payload`).
- `G`: Запрос генерации изображения (`session.post(cls.image_generation_url, ...)`).
- `H`: Извлечение идентификатора записи (`record_id`).
- `I`: Проверка статуса генерации (цикл `while True`).
- `J`: Обработка статуса и выдача результатов или информации о статусе.

**Примеры**:

```python
import asyncio
from typing import List, Dict

async def main():
    messages: List[Dict[str, str]] = [{"role": "user", "content": "Generate a futuristic city"}]
    async for result in ARTA.create_async_generator(model="Flux", messages=messages):
        print(result)

if __name__ == "__main__":
    asyncio.run(main())