# Модуль MetaAI

## Обзор

Модуль `MetaAI` предоставляет асинхронный интерфейс для взаимодействия с моделью Meta AI. Он включает в себя функциональность для получения доступа к ответам модели, обновления токенов доступа и обработки ответов, включая извлечение изображений и ссылок на источники.

## Подробнее

Этот модуль предназначен для использования в проектах, требующих интеграции с Meta AI для генерации текста и изображений. Он обеспечивает асинхронное взаимодействие, что позволяет эффективно обрабатывать запросы без блокировки основного потока выполнения.

## Классы

### `Sources`

**Описание**: Класс `Sources` представляет собой контейнер для хранения списка источников в виде словарей, содержащих информацию о ссылках.

**Принцип работы**: Класс принимает список словарей, где каждый словарь содержит ключи `'title'` и `'link'`. Он предоставляет удобный способ представления этих источников в виде строки Markdown.

**Методы**:
- `__init__(self, link_list: List[Dict[str, str]]) -> None`: Инициализирует объект `Sources` списком словарей, представляющих источники.
    - `link_list` (List[Dict[str, str]]): Список словарей, каждый из которых содержит ключи `'title'` и `'link'`.
- `__str__(self) -> str`: Возвращает строковое представление списка источников в формате Markdown.

### `AbraGeoBlockedError`

**Описание**: Класс `AbraGeoBlockedError` представляет собой исключение, которое выбрасывается, когда Meta AI недоступна в определенной географической локации.

### `MetaAI`

**Описание**: Класс `MetaAI` предоставляет асинхронный интерфейс для взаимодействия с моделью Meta AI.

**Принцип работы**: Класс инициализирует сессию `aiohttp` для выполнения асинхронных запросов. Он также управляет получением и обновлением токенов доступа, а также обрабатывает ответы от Meta AI, включая текст и изображения.

**Атрибуты**:
- `label` (str): Метка провайдера, "Meta AI".
- `url` (str): URL Meta AI, "https://www.meta.ai".
- `working` (bool): Указывает, работает ли провайдер (True).
- `default_model` (str): Модель по умолчанию, 'meta-ai'.
- `session` (ClientSession): Асинхронная сессия для выполнения запросов.
- `cookies` (Cookies): Куки для аутентификации.
- `access_token` (str): Токен доступа для Meta AI.

**Методы**:

#### `__init__`

```python
    def __init__(self, proxy: str = None, connector: BaseConnector = None):
        """
        Инициализирует экземпляр класса MetaAI.

        Args:
            proxy (str, optional): Прокси-сервер для использования при подключении. По умолчанию None.
            connector (BaseConnector, optional): Пользовательский коннектор aiohttp. По умолчанию None.
        """
```

#### `create_async_generator`

```python
    @classmethod
    async def create_async_generator(
        cls,
        model: str,
        messages: Messages,
        proxy: str = None,
        **kwargs
    ) -> AsyncResult:
        """
        Создает асинхронный генератор для взаимодействия с Meta AI.

        Args:
            model (str): Используемая модель.
            messages (Messages): Список сообщений для отправки.
            proxy (str, optional): Прокси-сервер для использования при подключении. По умолчанию None.
            **kwargs: Дополнительные параметры.

        Yields:
            AsyncResult: Части ответа от Meta AI.
        """
```

#### `update_access_token`

```python
    async def update_access_token(self, birthday: str = "1999-01-01"):
        """
        Обновляет токен доступа для Meta AI.

        Args:
            birthday (str, optional): Дата рождения пользователя. По умолчанию "1999-01-01".

        Raises:
            ResponseError: Если не удается получить токен доступа.
        """
```

#### `prompt`

```python
    async def prompt(self, message: str, cookies: Cookies = None) -> AsyncResult:
        """
        Отправляет запрос в Meta AI и возвращает асинхронный генератор с ответами.

        Args:
            message (str): Текст сообщения для отправки.
            cookies (Cookies, optional): Куки для использования. По умолчанию None.

        Yields:
            AsyncResult: Части ответа от Meta AI.

        Raises:
            ResponseError: Если Meta AI возвращает ошибку.
            RuntimeError: Если не удается декодировать JSON или возникают другие ошибки.
        """
```

**Как работает функция**:

1. **Проверка и обновление куки**:
   - Если `self.cookies` не установлены, вызывается `self.update_cookies(cookies)` для их обновления.
   - Если переданы новые `cookies`, токен доступа сбрасывается (`self.access_token = None`).

2. **Определение URL и payload**:
   - Если `self.access_token` отсутствует и `cookies` не переданы, вызывается `self.update_access_token()` для получения токена.
   - В зависимости от наличия `self.access_token` формируется URL и payload для запроса. Если токен есть, используется `https://graph.meta.ai/graphql?locale=user` и передается `access_token`. Если токена нет, используется `https://www.meta.ai/api/graphql/` и передаются `lsd` и `fb_dtsg`.

3. **Формирование заголовков**:
   - Формируются заголовки запроса, включая `content-type`, `cookie`, `origin`, `referer`, `x-asbd-id` и `x-fb-friendly-name`.

4. **Отправка запроса и обработка ответа**:
   - Отправляется POST-запрос с использованием `self.session.post()`.
   - В случае ошибки HTTP, выбрасывается исключение `ResponseError`.
   - Асинхронно читаются строки из ответа:
     - При обнаружении `<h1>Something Went Wrong</h1>` выбрасывается исключение `ResponseError`.
     - Каждая строка преобразуется в JSON. В случае ошибки декодирования JSON, строка пропускается.
     - Если в JSON есть ошибки (`json_line.get("errors")`), выбрасывается исключение `RuntimeError`.
     - Извлекается `bot_response_message` и `streaming_state` из JSON.
     - Если `streaming_state` равен `"STREAMING"` или `"OVERALL_DONE"`, обрабатываются данные изображения (`imagine_card`) и текста (`snippet`):
       - Для изображений извлекаются URI и формируется объект `ImageResponse` или `ImagePreview`, который возвращается через `yield`.
       - Для текста извлекается новый фрагмент (`snippet`) и возвращается через `yield`.
   
5. **Обработка источников**:
   - После завершения стриминга, если `fetch_id` не равен `None`, вызывается `self.fetch_sources(fetch_id)` для получения ссылок на источники.
   - Если источники найдены, они возвращаются через `yield`.

**ASCII flowchart**:

```
   Начало
   ↓
   Проверка/обновление куки -> Определение URL и payload -> Формирование заголовков
   ↓
   Отправка POST-запроса
   ↓
   Асинхронное чтение строк из ответа
   ↓
   Обработка каждой строки:
     - Обнаружена ошибка? -> Выброс исключения ResponseError
     - Декодирование JSON -> Извлечение данных (bot_response_message, streaming_state)
     - streaming_state == "STREAMING" или "OVERALL_DONE"?
       ↓
       Да -> Обработка изображений и текста -> Возврат через yield
       ↓
       Нет -> Продолжение обработки
   ↓
   Завершение обработки ответа -> Получение источников (fetch_sources) -> Возврат через yield (если есть)
   ↓
   Конец
```

#### `update_cookies`

```python
    async def update_cookies(self, cookies: Cookies = None):
        """
        Обновляет куки для сессии Meta AI.

        Args:
            cookies (Cookies, optional): Куки для обновления. По умолчанию None.

        Raises:
            AbraGeoBlockedError: Если Meta AI недоступна в данной географической локации.
            ResponseError: Если не удается получить куки.
        """
```

#### `fetch_sources`

```python
    async def fetch_sources(self, fetch_id: str) -> Sources:
        """
        Получает источники для заданного fetch_id.

        Args:
            fetch_id (str): Идентификатор запроса.

        Returns:
            Sources: Объект Sources, содержащий список источников.

        Raises:
            ResponseError: Если не удается получить источники.
            RuntimeError: Если не удается декодировать JSON или возникают другие ошибки.
        """
```

**Как работает функция**:

1. **Определение URL и payload**:
   - В зависимости от наличия `self.access_token` формируется URL и payload для запроса. Если токен есть, используется `https://graph.meta.ai/graphql?locale=user` и передается `access_token`. Если токена нет, используется `https://www.meta.ai/api/graphql/` и передаются `lsd` и `fb_dtsg`.

2. **Формирование заголовков**:
   - Формируются заголовки запроса, включая `authority` и `x-fb-friendly-name`.

3. **Отправка запроса и обработка ответа**:
   - Отправляется POST-запрос с использованием `self.session.post()`.
   - В случае ошибки HTTP, выбрасывается исключение `ResponseError`.
   - Анализируется текст ответа:
     - При обнаружении `<h1>Something Went Wrong</h1>` выбрасывается исключение `ResponseError`.
   - Текст ответа преобразуется в JSON. В случае ошибки декодирования JSON или других ошибок, выбрасывается исключение `RuntimeError`.
   - Из JSON извлекается список источников (`searchResults`) и возвращается в виде объекта `Sources`.

**ASCII flowchart**:

```
   Начало
   ↓
   Определение URL и payload -> Формирование заголовков
   ↓
   Отправка POST-запроса
   ↓
   Анализ текста ответа:
     - Обнаружена ошибка? -> Выброс исключения ResponseError
   ↓
   Преобразование текста в JSON -> Извлечение списка источников (searchResults)
   ↓
   Возврат списка источников в виде объекта Sources
   ↓
   Конец
```

#### `extract_value`

```python
    @staticmethod
    def extract_value(text: str, key: str = None, start_str = None, end_str = \',\') -> str:
        """
        Извлекает значение из текста по заданным ключам и строкам.

        Args:
            text (str): Текст для поиска.
            key (str, optional): Ключ для поиска начальной строки. По умолчанию None.
            start_str (str, optional): Начальная строка для поиска. По умолчанию None.
            end_str (str, optional): Конечная строка для поиска. По умолчанию ','.

        Returns:
            str: Извлеченное значение.
        """
```

## Функции

### `generate_offline_threading_id`

```python
def generate_offline_threading_id() -> str:
    """
    Generates an offline threading ID.

    Returns:
        str: The generated offline threading ID.
    """
```

**Назначение**:
Функция `generate_offline_threading_id` генерирует идентификатор треда для оффлайн-режима.

**Параметры**:
- Функция не принимает входных параметров.

**Возвращает**:
- `str`: Сгенерированный идентификатор треда в виде строки.

**Как работает функция**:

1. **Генерация случайного значения**:
   - Генерируется случайное 64-битное целое число с использованием `random.getrandbits(64)`.

2. **Получение текущей метки времени**:
   - Получается текущая метка времени в миллисекундах с использованием `time.time() * 1000` и преобразуется в целое число.

3. **Объединение метки времени и случайного значения**:
   - Метка времени сдвигается влево на 22 бита (`timestamp << 22`), а случайное значение обрезается до 22 бит (`random_value & ((1 << 22) - 1)`).
   - Затем они объединяются с помощью побитовой операции ИЛИ (`|`).

4. **Преобразование в строку**:
   - Полученный идентификатор треда преобразуется в строку и возвращается.

**ASCII flowchart**:

```
   Начало
   ↓
   Генерация случайного 64-битного числа
   ↓
   Получение текущей метки времени в миллисекундах
   ↓
   Сдвиг метки времени влево на 22 бита и обрезка случайного числа до 22 бит
   ↓
   Объединение метки времени и случайного числа
   ↓
   Преобразование в строку
   ↓
   Конец
```

**Примеры**:

```python
offline_id = generate_offline_threading_id()
print(f"Generated offline threading ID: {offline_id}")
# Пример вывода: Generated offline threading ID: 167888648524858368
```