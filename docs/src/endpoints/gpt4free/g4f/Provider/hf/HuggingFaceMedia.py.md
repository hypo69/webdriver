# Модуль HuggingFaceMedia

## Обзор

Модуль `HuggingFaceMedia` предоставляет функциональность для генерации изображений и видео, используя модели, размещенные на платформе Hugging Face. Он поддерживает как асинхронную генерацию, так и работу с различными провайдерами внутри Hugging Face.

## Подробнее

Этот модуль позволяет пользователям генерировать медиа-контент (изображения и видео) на основе текстовых запросов, используя различные модели и API, предоставляемые Hugging Face. Он поддерживает различные задачи, такие как преобразование текста в изображение (`text-to-image`) и преобразование текста в видео (`text-to-video`). Модуль включает в себя функции для выбора моделей, настройки параметров генерации и обработки ответов от API Hugging Face.

## Классы

### `HuggingFaceMedia`

**Описание**: Класс `HuggingFaceMedia` реализует функциональность для генерации изображений и видео с использованием моделей Hugging Face.

**Наследует**:
- `AsyncGeneratorProvider`: Обеспечивает асинхронную генерацию.
- `ProviderModelMixin`: Предоставляет методы для работы с моделями.

**Атрибуты**:
- `label` (str): Метка провайдера (по умолчанию `"HuggingFace (Image/Video Generation)"`).
- `parent` (str): Родительский провайдер (по умолчанию `"HuggingFace"`).
- `url` (str): URL главной страницы Hugging Face (по умолчанию `"https://huggingface.co"`).
- `working` (bool): Указывает, работает ли провайдер (по умолчанию `True`).
- `needs_auth` (bool): Указывает, требуется ли аутентификация (по умолчанию `True`).
- `tasks` (List[str]): Список поддерживаемых задач (по умолчанию `["text-to-image", "text-to-video"]`).
- `provider_mapping` (Dict[str, Dict]): Словарь для хранения соответствий между моделями и провайдерами.
- `task_mapping` (Dict[str, str]): Словарь для хранения соответствий между моделями и задачами.
- `models` (List[str]): Список доступных моделей.
- `image_models` (List[str]): Список моделей для генерации изображений.
- `video_models` (List[str]): Список моделей для генерации видео.

**Методы**:
- `get_models(**kwargs)`: Возвращает список доступных моделей.
- `get_mapping(model: str, api_key: str = None)`: Возвращает информацию о провайдерах для указанной модели.
- `create_async_generator(model: str, messages: Messages, api_key: str = None, extra_data: dict = {}, prompt: str = None, proxy: str = None, timeout: int = 0, n: int = 1, aspect_ratio: str = None, height: int = None, width: int = None, resolution: str = "480p", **kwargs)`: Создает асинхронный генератор для генерации изображений или видео.

## Функции

### `get_models`

```python
@classmethod
def get_models(cls, **kwargs) -> list[str]:
    """Получает список доступных моделей для генерации медиа-контента на Hugging Face.

    Args:
        **kwargs: Дополнительные аргументы (не используются).

    Returns:
        list[str]: Список строк, представляющих доступные модели.

    Raises:
        Exception: Возникает, если не удается получить список моделей с Hugging Face.
    """
```

**Назначение**:
Функция `get_models` извлекает список доступных моделей для генерации медиа-контента с платформы Hugging Face.  Этот список используется для выбора конкретной модели при создании запросов на генерацию изображений или видео.

**Как работает функция**:

1. **Проверка наличия моделей в кэше**: Проверяется, был ли уже загружен список моделей в атрибут класса `cls.models`. Если список уже существует, он возвращается немедленно.
2. **Запрос к API Hugging Face**: Если список моделей отсутствует, выполняется HTTP-запрос к API Hugging Face для получения информации о моделях.
3. **Обработка ответа**: В случае успешного ответа (status code 200), полученные данные JSON парсятся для извлечения информации о моделях, поддерживаемых задачах (`text-to-image`, `text-to-video`) и провайдерах.
4. **Формирование списка моделей**: Из полученных данных формируется список доступных моделей.
5. **Кэширование списка**: Полученный список моделей сохраняется в атрибуте класса `cls.models` для последующего использования.

**Примеры**:

```python
models = HuggingFaceMedia.get_models()
print(models)
# ['stable-diffusion-v1-5', 'sdxl-turbo', ...]
```

### `get_mapping`

```python
@classmethod
async def get_mapping(cls, model: str, api_key: str = None) -> dict:
    """Получает информацию о провайдерах для указанной модели на Hugging Face.

    Args:
        model (str): Название модели.
        api_key (str, optional): API-ключ для аутентификации. По умолчанию `None`.

    Returns:
        dict: Словарь с информацией о провайдерах для указанной модели.

    Raises:
        Exception: Если возникает ошибка при получении информации о провайдерах.
    """
```

**Назначение**:
Функция `get_mapping` извлекает информацию о провайдерах, связанных с указанной моделью на платформе Hugging Face. Эта информация включает в себя данные, необходимые для маршрутизации запросов к правильному API и для настройки параметров генерации.

**Как работает функция**:

1. **Проверка наличия информации в кэше**: Проверяется, есть ли информация о провайдерах для указанной модели в атрибуте класса `cls.provider_mapping`. Если информация уже существует, она возвращается немедленно.
2. **Формирование заголовков запроса**: Формируются заголовки HTTP-запроса, включая API-ключ, если он предоставлен.
3. **Запрос к API Hugging Face**: Выполняется асинхронный HTTP-запрос к API Hugging Face для получения информации о провайдерах для указанной модели.
4. **Обработка ответа**: В случае успешного ответа, полученные данные JSON парсятся для извлечения информации о провайдерах, поддерживающих модель.
5. **Кэширование информации**: Полученная информация о провайдерах сохраняется в атрибуте класса `cls.provider_mapping` для последующего использования.

**Примеры**:

```python
model_mapping = await HuggingFaceMedia.get_mapping(model="stable-diffusion-v1-5", api_key="YOUR_API_KEY")
print(model_mapping)
# {'replicate': {'status': 'live', 'task': 'text-to-image', ...}, ...}
```

### `create_async_generator`

```python
@classmethod
async def create_async_generator(
    cls,
    model: str,
    messages: Messages,
    api_key: str = None,
    extra_data: dict = {},
    prompt: str = None,
    proxy: str = None,
    timeout: int = 0,
    # Video & Image Generation
    n: int = 1,
    aspect_ratio: str = None,
    # Only for Image Generation
    height: int = None,
    width: int = None,
    # Video Generation
    resolution: str = "480p",
    **kwargs
) -> AsyncGenerator:
    """Создает асинхронный генератор для генерации медиа-контента на Hugging Face.

    Args:
        model (str): Название модели для генерации.
        messages (Messages): Список сообщений для формирования запроса.
        api_key (str, optional): API-ключ для аутентификации. По умолчанию `None`.
        extra_data (dict, optional): Дополнительные данные для запроса. По умолчанию `{}`.
        prompt (str, optional): Текстовый запрос для генерации. По умолчанию `None`.
        proxy (str, optional): URL прокси-сервера. По умолчанию `None`.
        timeout (int, optional): Время ожидания запроса в секундах. По умолчанию `0`.
        n (int, optional): Количество генерируемых медиа-файлов. По умолчанию `1`.
        aspect_ratio (str, optional): Соотношение сторон генерируемого медиа. По умолчанию `None`.
        height (int, optional): Высота генерируемого изображения. По умолчанию `None`.
        width (int, optional): Ширина генерируемого изображения. По умолчанию `None`.
        resolution (str, optional): Разрешение генерируемого видео. По умолчанию `"480p"`.
        **kwargs: Дополнительные аргументы.

    Yields:
        AsyncGenerator: Асинхронный генератор, выдающий результаты генерации.

    Raises:
        ModelNotSupportedError: Если указанная модель не поддерживается.
        Exception: Если возникает ошибка при генерации медиа-контента.
    """
```

**Назначение**:
Функция `create_async_generator` создает асинхронный генератор для генерации медиа-контента (изображений и видео) на основе текстового запроса, используя модели, размещенные на платформе Hugging Face.

**Как работает функция**:

1. **Подготовка параметров**:
   - Определяется модель и провайдер (если указан). Если модель не указана, используется первая доступная модель из списка.
   - Формируется текстовый запрос на основе предоставленных сообщений и промпта.

2. **Получение информации о провайдерах**:
   - Извлекается информация о провайдерах для выбранной модели с использованием функции `cls.get_mapping`.

3. **Формирование запросов к API**:
   - Для каждого провайдера формируется URL и данные запроса в зависимости от спецификации API провайдера.

4. **Асинхронная генерация**:
   - Используется асинхронный генератор для выполнения запросов к API и получения результатов генерации.

5. **Обработка ответов**:
   - Обрабатываются ответы от API, извлекаются URL сгенерированных медиа-файлов (изображений или видео) и возвращаются в виде объектов `ImageResponse` или `VideoResponse`.

6. **Параллельное выполнение**:
   - Функция поддерживает параллельное выполнение нескольких задач генерации с использованием `asyncio`.

7. **Возврат результатов**:
   - Результаты генерации возвращаются в виде асинхронного генератора, который выдает объекты `ProviderInfo` (информация о провайдере) и `ImageResponse` или `VideoResponse` (результаты генерации).

**Внутренние функции**:

### `generate`

```python
async def generate(extra_data: dict, aspect_ratio: str = None) -> AsyncGenerator:
    """Внутренняя функция для генерации медиа-контента с использованием выбранного провайдера.

    Args:
        extra_data (dict): Дополнительные данные для запроса.
        aspect_ratio (str, optional): Соотношение сторон генерируемого медиа. По умолчанию `None`.

    Yields:
        AsyncGenerator: Асинхронный генератор, выдающий результаты генерации.

    Raises:
        ModelNotSupportedError: Если указанная модель не поддерживается.
        Exception: Если возникает ошибка при генерации медиа-контента.
    """
```

**Назначение**:
Внутренняя функция `generate` отвечает за фактическую генерацию медиа-контента с использованием выбранного провайдера.

**Как работает функция**:

1. **Итерация по провайдерам**:
   - Функция перебирает доступных провайдеров из `provider_mapping`. Если указан конкретный провайдер (`selected_provider`), используется только он.

2. **Формирование информации о провайдере**:
   - Создается объект `ProviderInfo` с информацией о текущем провайдере.

3. **Формирование URL и данных запроса**:
   - В зависимости от провайдера и задачи (генерация изображения или видео) формируется URL для запроса к API провайдера и данные запроса.

4. **Выполнение запроса к API**:
   - Выполняется асинхронный HTTP-запрос к API провайдера с использованием `StreamSession`.

5. **Обработка ответа**:
   - Обрабатывается ответ от API, проверяются коды состояния (например, 400, 401, 404). В случае ошибок выполняется повторная попытка с другим провайдером (если есть).
   - Извлекаются URL сгенерированных медиа-файлов (изображений или видео) и возвращаются в виде объектов `ImageResponse` или `VideoResponse`.

**ASII flowchart**:

```
    Начало
    ↓
    → Итерация по провайдерам (provider_key, provider)
    │
    → Проверка выбранного провайдера (selected_provider)
    │
    → Формирование ProviderInfo
    │
    → Формирование URL (api_base, provider_id)
    │
    → Формирование данных запроса (data)
    │
    → Выполнение POST-запроса (session.post)
    │
    → Обработка ответа (response.status)
    │   ├── 400, 401, 402: Ошибка, переход к следующему провайдеру
    │   ├── 404: ModelNotSupportedError
    │   └── 200: Успех, извлечение и возврат ImageResponse/VideoResponse
    ↓
    Конец
```

**Примеры**:

```python
async for result in HuggingFaceMedia.create_async_generator(
    model="stable-diffusion-v1-5",
    messages=[{"role": "user", "content": "A futuristic cityscape"}],
    api_key="YOUR_API_KEY",
    n=2
):
    print(result)
# ProviderInfo(label='HuggingFace (replicate)', url='https://huggingface.co/stable-diffusion-v1-5')
# ImageResponse(images=['https://replicate.com/...'], prompt='A futuristic cityscape')
# ProviderInfo(label='HuggingFace (replicate)', url='https://huggingface.co/stable-diffusion-v1-5')
# ImageResponse(images=['https://replicate.com/...'], prompt='A futuristic cityscape')