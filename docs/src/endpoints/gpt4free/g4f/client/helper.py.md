# Модуль `helper.py`

## Обзор

Модуль `helper.py` содержит набор вспомогательных функций для обработки текста, включая извлечение блоков кода, фильтрацию JSON и управление генераторами. Эти функции предназначены для облегчения разбора и очистки текстовых данных, особенно в контексте работы с моделями генерации текста.

## Подробнее

Этот модуль предоставляет инструменты для работы с текстом, содержащим блоки кода, JSON-данные и другие структурированные форматы. Он включает функции для поиска и фильтрации содержимого, а также для безопасного закрытия асинхронных генераторов. Функции модуля используются для предварительной обработки и очистки данных, что важно для обеспечения корректной работы других компонентов проекта.

## Функции

### `filter_markdown`

```python
def filter_markdown(text: str, allowd_types=None, default=None) -> str:
    """
    Parses code block from a string.

    Args:
        text (str): A string containing a code block.
        allowd_types (list[str], optional): Список разрешенных типов блоков кода. По умолчанию `None`.
        default (str, optional): Значение по умолчанию, возвращаемое в случае отсутствия совпадений. По умолчанию `None`.

    Returns:
        str: Код, извлеченный из блока кода, или значение `default`, если совпадение не найдено.
    """
```

**Назначение**: Извлекает блок кода из строки, используя регулярное выражение.

**Параметры**:
- `text` (str): Строка, содержащая блок кода.
- `allowd_types` (list[str], optional): Список разрешенных типов блоков кода. Если `None`, разрешены все типы. По умолчанию `None`.
- `default` (str, optional): Значение по умолчанию, возвращаемое в случае, если блок кода не найден или его тип не разрешен. По умолчанию `None`.

**Возвращает**:
- `str`: Код, извлеченный из блока кода, или значение `default`, если совпадение не найдено.

**Как работает функция**:

1. **Поиск блока кода**: Функция использует регулярное выражение для поиска блока кода, заключенного между маркерами ```.
2. **Проверка типа**: Если указан список разрешенных типов (`allowd_types`), функция проверяет, соответствует ли тип найденного блока кода одному из разрешенных типов.
3. **Извлечение кода**: Если блок кода найден и его тип разрешен (или список разрешенных типов не указан), функция извлекает код из блока.
4. **Возврат значения**: Если блок кода найден и соответствует условиям, функция возвращает извлеченный код. В противном случае возвращается значение `default`.

```ascii
    +-----------------+
    |      Начало     |
    +--------+--------+
           |
    +-------v--------+
    | Поиск ```...``` |
    +-------+--------+
           |
    +-------v--------+
    |  Тип в allowd_types?  |
    +-------+--------+
           | Да
    +-------v--------+
    | Извлечение кода |
    +-------+--------+
           |
    +-------v--------+
    |     Возврат     |
    +-----------------+
           | Нет
    +-------v--------+
    | Возврат default |
    +-----------------+
```

**Примеры**:

```python
text = "```python\nprint('Hello, world!')\n```"
code = filter_markdown(text)
print(code)
# Output: print('Hello, world!')

text = "```json\n{'key': 'value'}\n```"
code = filter_markdown(text, allowd_types=['python'])
print(code)
# Output: None

text = "```json\n{'key': 'value'}\n```"
code = filter_markdown(text, allowd_types=['json'], default='{}')
print(code)
# Output: {'key': 'value'}
```

### `filter_json`

```python
def filter_json(text: str) -> str:
    """
    Parses JSON code block from a string.

    Args:
        text (str): A string containing a JSON code block.

    Returns:
        dict: A dictionary parsed from the JSON code block.
    """
```

**Назначение**: Извлекает JSON блок кода из строки.

**Параметры**:
- `text` (str): Строка, содержащая JSON блок кода.

**Возвращает**:
- `str`: JSON блок кода, извлеченный из строки.

**Как работает функция**:

1. **Вызов `filter_markdown`**: Функция вызывает функцию `filter_markdown` с параметрами `text`, `allowd_types` установленным в `["", "json"]`, и `default` установленным в `text.strip("^\\n ")`.
2. **Возврат значения**: Функция возвращает результат, полученный от вызова `filter_markdown`.

```ascii
    +-----------------+
    |      Начало     |
    +--------+--------+
           |
    +-------v--------+
    |  Вызов filter_markdown()  |
    +-------+--------+
           |
    +-------v--------+
    |     Возврат     |
    +-----------------+
```

**Примеры**:

```python
text = "```json\n{'key': 'value'}\n```"
json_code = filter_json(text)
print(json_code)
# Output: {'key': 'value'}

text = "{'key': 'value'}"
json_code = filter_json(text)
print(json_code)
# Output: {'key': 'value'}
```

### `find_stop`

```python
def find_stop(stop: Optional[list[str]], content: str, chunk: str = None):
    """
    Находит первое вхождение стоп-слова в строке.

    Args:
        stop (Optional[list[str]]): Список стоп-слов для поиска.
        content (str): Строка, в которой производится поиск.
        chunk (str, optional): Дополнительная строка для поиска. По умолчанию `None`.

    Returns:
        tuple[int, str, str]: Кортеж, содержащий индекс первого вхождения стоп-слова,
                             обрезанную строку `content` и обрезанную строку `chunk`.
    """
```

**Назначение**: Находит первое вхождение одного из стоп-слов в заданной строке и возвращает индекс этого вхождения, а также обрезанные строки.

**Параметры**:
- `stop` (Optional[list[str]]): Список стоп-слов для поиска. Если `None`, поиск не производится.
- `content` (str): Строка, в которой производится поиск.
- `chunk` (str, optional): Дополнительная строка для поиска и обрезки. По умолчанию `None`.

**Возвращает**:
- `tuple[int, str, str]`: Кортеж, содержащий:
  - `int`: Индекс первого вхождения стоп-слова (или -1, если стоп-слова не найдены).
  - `str`: Обрезанная строка `content` до первого вхождения стоп-слова (или исходная строка, если стоп-слова не найдены).
  - `str`: Обрезанная строка `chunk` до первого вхождения стоп-слова (или исходная строка, если стоп-слова не найдены или `chunk` равен `None`).

**Как работает функция**:

1. **Проверка стоп-слов**: Функция проверяет, предоставлен ли список стоп-слов (`stop`). Если `stop` равен `None`, функция пропускает поиск стоп-слов.
2. **Поиск стоп-слов**: Если список стоп-слов предоставлен, функция итерируется по списку и ищет первое вхождение каждого стоп-слова в строке `content`.
3. **Обрезка строк**: Если стоп-слово найдено, функция обрезает строку `content` до первого вхождения стоп-слова. Если также предоставлена строка `chunk`, она также обрезается до первого вхождения стоп-слова.
4. **Возврат значений**: Функция возвращает кортеж, содержащий индекс первого вхождения стоп-слова, обрезанную строку `content` и обрезанную строку `chunk`.

```ascii
    +-----------------+
    |      Начало     |
    +--------+--------+
           |
    +-------v--------+
    |  stop is None?  |
    +-------+--------+
           | Нет
    +-------v--------+
    |  Поиск stop words в content  |
    +-------+--------+
           |
    +-------v--------+
    |  stop word найдено?  |
    +-------+--------+
           | Да
    +-------v--------+
    |  Обрезать content и chunk  |
    +-------+--------+
           |
    +-------v--------+
    |     Возврат     |
    +-----------------+
           | Да
    +-------v--------+
    | Возврат (-1, content, chunk) |
    +-----------------+
```

**Примеры**:

```python
stop_words = ["stop", "end"]
content = "This is a stop word."
chunk = "This is a chunk of text."
index, new_content, new_chunk = find_stop(stop_words, content, chunk)
print(index, new_content, new_chunk)
# Output: 10 This is a   This is a 

stop_words = ["stop", "end"]
content = "This is a test."
chunk = "This is a chunk of text."
index, new_content, new_chunk = find_stop(stop_words, content, chunk)
print(index, new_content, new_chunk)
# Output: -1 This is a test. This is a chunk of text.
```

### `filter_none`

```python
def filter_none(**kwargs) -> dict:
    """
    Создает словарь, содержащий только ненулевые значения из переданных аргументов.

    Args:
        **kwargs: Произвольные именованные аргументы.

    Returns:
        dict: Словарь, содержащий только аргументы с ненулевыми значениями.
    """
```

**Назначение**: Создает новый словарь, исключая элементы с `None` значениями из входных аргументов.

**Параметры**:
- `**kwargs`: Произвольные именованные аргументы, которые будут отфильтрованы.

**Возвращает**:
- `dict`: Новый словарь, содержащий только те элементы из `kwargs`, значения которых не равны `None`.

**Как работает функция**:

1. **Итерация по аргументам**: Функция итерируется по всем переданным именованным аргументам (`kwargs`).
2. **Проверка на `None`**: Для каждого аргумента функция проверяет, является ли его значение `None`.
3. **Создание нового словаря**: Если значение аргумента не равно `None`, функция добавляет этот аргумент в новый словарь.
4. **Возврат нового словаря**: Функция возвращает новый словарь, содержащий только аргументы с ненулевыми значениями.

```ascii
    +-----------------+
    |      Начало     |
    +--------+--------+
           |
    +-------v--------+
    |  Итерация по kwargs  |
    +-------+--------+
           |
    +-------v--------+
    |  value is None?  |
    +-------+--------+
           | Нет
    +-------v--------+
    |  Добавить в новый словарь  |
    +-------+--------+
           |
    +-------v--------+
    |     Возврат     |
    +-----------------+
           | Да
    +-------v--------+
    |  Пропустить   |
    +-----------------+
```

**Примеры**:

```python
filtered_dict = filter_none(a=1, b=None, c="hello")
print(filtered_dict)
# Output: {'a': 1, 'c': 'hello'}

filtered_dict = filter_none(x=None, y=None)
print(filtered_dict)
# Output: {}
```

### `safe_aclose`

```python
async def safe_aclose(generator: AsyncGenerator) -> None:
    """
    Безопасно закрывает асинхронный генератор.

    Args:
        generator (AsyncGenerator): Асинхронный генератор, который необходимо закрыть.

    Raises:
        Exception: Если при закрытии генератора возникает исключение.
    """
```

**Назначение**: Безопасное закрытие асинхронного генератора.

**Параметры**:
- `generator` (AsyncGenerator): Асинхронный генератор, который необходимо закрыть.

**Вызывает исключения**:
- `Exception`: Если при закрытии генератора возникает исключение.

**Как работает функция**:

1. **Проверка генератора**: Функция проверяет, существует ли генератор и имеет ли он атрибут `aclose`.
2. **Закрытие генератора**: Если генератор существует и имеет атрибут `aclose`, функция пытается закрыть генератор, вызывая метод `aclose`.
3. **Обработка исключений**: Если при закрытии генератора возникает исключение, функция перехватывает исключение и логирует предупреждение.

```ascii
    +-----------------+
    |      Начало     |
    +--------+--------+
           |
    +-------v--------+
    |  generator и aclose?  |
    +-------+--------+
           | Да
    +-------v--------+
    |  Попытка generator.aclose()  |
    +-------+--------+
           |
    +-------v--------+
    |  Исключение?   |
    +-------+--------+
           | Нет
    +-------v--------+
    |     Конец     |
    +-----------------+
           | Да
    +-------v--------+
    |  Логирование предупреждения |
    +-----------------+
```

**Примеры**:

```python
async def my_generator():
    yield 1
    yield 2

async def main():
    gen = my_generator()
    try:
        async for i in gen:
            print(i)
    finally:
        await safe_aclose(gen)

# Вызов функции main
# >>> asyncio.run(main())