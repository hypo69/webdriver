# Модуль helper

## Обзор

Модуль содержит вспомогательные функции, используемые для форматирования и обработки текстовых сообщений, генерации случайных строк и работы с данными. Функции предназначены для подготовки данных перед их отправкой в языковые модели и для обработки ответов, полученных от этих моделей.

## Подробней

Модуль предоставляет набор функций для преобразования различных типов данных в строки, форматирования промптов для языковых моделей, получения системных сообщений, обработки последних сообщений пользователей, форматирования изображений, обрезки длинных промптов, генерации случайных строк и шестнадцатеричных значений, фильтрации None значений, объединения чанков и форматирования куки.

## Функции

### `to_string`

```python
def to_string(value) -> str:
    """
    Преобразует значение в строку.

    Args:
        value: Значение для преобразования. Может быть строкой, словарем или списком.

    Returns:
        str: Строковое представление значения.
    """
    ...
```

**Назначение**: Преобразует входное значение в строковый формат. Функция обрабатывает различные типы данных, такие как строки, словари и списки, извлекая текстовое содержимое или объединяя элементы в строку.

**Параметры**:
- `value`: Значение, которое необходимо преобразовать в строку. Может быть экземпляром `str`, `dict` или `list`.

**Возвращает**:
- `str`: Строковое представление входного значения.

**Как работает функция**:

1.  **Проверка типа**: Определяет тип входного значения `value`.
2.  **Обработка строки**: Если `value` уже является строкой, функция возвращает его без изменений.
3.  **Обработка словаря**: Если `value` является словарем, функция проверяет наличие определенных ключей (`name`, `bucket_id`, `type`) и, в зависимости от их наличия, выполняет различные действия:
    *   Если есть ключ `"name"`, возвращает пустую строку.
    *   Если есть ключ `"bucket_id"`, пытается прочитать содержимое бакета с указанным идентификатором и возвращает объединенную строку из прочитанных данных.
    *   Если есть ключ `"type"` со значением `"text"`, возвращает текст из ключа `"text"`.
    *   В противном случае возвращает пустую строку.
4.  **Обработка списка**: Если `value` является списком, функция рекурсивно преобразует каждый элемент списка в строку с помощью этой же функции (`to_string`) и объединяет полученные строки в одну. Учитываются только элементы, у которых ключ `"type"` имеет значение `"text"`.
5.  **Обработка других типов**: Если `value` не является строкой, словарем или списком, функция преобразует его в строку с помощью стандартной функции `str()`.

**Примеры**:

```python
>>> to_string("test")
'test'

>>> to_string({"type": "text", "text": "example"})
'example'

>>> to_string([{"type": "text", "text": "hello"}, {"type": "text", "text": "world"}])
'helloworld'
```

### `format_prompt`

```python
def format_prompt(messages: Messages, add_special_tokens: bool = False, do_continue: bool = False, include_system: bool = True) -> str:
    """
    Форматирует серию сообщений в одну строку, при необходимости добавляя специальные токены.

    Args:
        messages (Messages): Список словарей сообщений, каждый из которых содержит 'role' и 'content'.
        add_special_tokens (bool): Нужно ли добавлять специальные токены форматирования.
        do_continue (bool): Флаг, указывающий, нужно ли продолжать форматирование.
        include_system (bool): Флаг, указывающий, нужно ли включать системные сообщения.

    Returns:
        str: Отформатированная строка, содержащая все сообщения.
    """
    ...
```

**Назначение**: Форматирует список сообщений в единую строку, опционально добавляя специальные токены для форматирования.

**Параметры**:
- `messages` (Messages): Список словарей, где каждый словарь представляет собой сообщение и содержит ключи `"role"` (роль отправителя) и `"content"` (содержимое сообщения).
- `add_special_tokens` (bool): Флаг, определяющий, следует ли добавлять специальные токены форматирования в строку. По умолчанию `False`.
- `do_continue` (bool): Флаг, определяющий, следует ли продолжать форматирование. Если `True`, то возвращается отформатированная строка без добавления `"Assistant:"` в конце. По умолчанию `False`.
- `include_system` (bool): Флаг, определяющий, следует ли включать сообщения с ролью `"system"` в форматирование. По умолчанию `True`.

**Возвращает**:
- `str`: Отформатированная строка, содержащая все сообщения.

**Как работает функция**:

1.  **Проверка специальных токенов и количества сообщений**: Если `add_special_tokens` равен `False` и количество сообщений меньше или равно 1, функция возвращает содержимое первого сообщения, преобразованное в строку.
2.  **Фильтрация сообщений**: Функция создает новый список сообщений, исключая системные сообщения, если `include_system` равен `False`.
3.  **Форматирование**: Функция объединяет сообщения в строку, добавляя роль отправителя в начале каждой строки.
4.  **Добавление "Assistant:"**: Если `do_continue` равен `False`, функция добавляет `"Assistant:"` в конец отформатированной строки.

```
Форматирование сообщений
│
├── Проверка add_special_tokens и количества сообщений
│   └── Если add_special_tokens=False и len(messages) <= 1: Возврат содержимого первого сообщения
│
├── Фильтрация сообщений (исключение системных, если include_system=False)
│
└── Форматирование сообщений в строку с ролями отправителей
    │
    └── Добавление "Assistant:" в конец, если do_continue=False
    │
    └── Возврат отформатированной строки
```

**Примеры**:

```python
>>> messages = [{"role": "user", "content": "Hello"}, {"role": "assistant", "content": "Hi"}]
>>> format_prompt(messages)
'User: Hello\nAssistant: Hi\nAssistant:'

>>> format_prompt(messages, add_special_tokens=True)
'User: Hello\nAssistant: Hi\nAssistant:'

>>> format_prompt(messages, do_continue=True)
'User: Hello\nAssistant: Hi'

>>> format_prompt(messages, include_system=False)
'User: Hello\nAssistant: Hi\nAssistant:'
```

### `get_system_prompt`

```python
def get_system_prompt(messages: Messages) -> str:
    """
    Извлекает системные сообщения из списка сообщений и объединяет их в одну строку.

    Args:
        messages (Messages): Список словарей сообщений, каждый из которых содержит 'role' и 'content'.

    Returns:
        str: Объединенная строка, содержащая все системные сообщения.
    """
    ...
```

**Назначение**: Извлекает все сообщения с ролью `"system"` из списка сообщений и объединяет их в одну строку, разделяя символом новой строки.

**Параметры**:
- `messages` (Messages): Список словарей, где каждый словарь представляет собой сообщение и содержит ключи `"role"` (роль отправителя) и `"content"` (содержимое сообщения).

**Возвращает**:
- `str`: Строка, содержащая все системные сообщения, объединенные символом новой строки.

**Как работает функция**:

1.  **Фильтрация сообщений**: Функция проходит по списку сообщений и выбирает только те, у которых роль (`"role"`) равна `"system"`.
2.  **Извлечение содержимого**: Из каждого выбранного сообщения извлекается содержимое (`"content"`).
3.  **Объединение сообщений**: Содержимое всех системных сообщений объединяется в одну строку, разделяясь символом новой строки (`"\n"`).

```
Получение системных сообщений
│
├── Фильтрация сообщений (выбор только с role="system")
│
└── Извлечение содержимого из каждого системного сообщения
    │
    └── Объединение содержимого в строку с разделителем "\n"
    │
    └── Возврат объединенной строки
```

**Примеры**:

```python
>>> messages = [{"role": "system", "content": "You are a helpful assistant."}, {"role": "user", "content": "Hello"}]
>>> get_system_prompt(messages)
'You are a helpful assistant.'

>>> messages = [{"role": "system", "content": "You are a helpful assistant."}, {"role": "system", "content": "Be concise."}]
>>> get_system_prompt(messages)
'You are a helpful assistant.\nBe concise.'

>>> messages = [{"role": "user", "content": "Hello"}]
>>> get_system_prompt(messages)
''
```

### `get_last_user_message`

```python
def get_last_user_message(messages: Messages) -> str:
    """
    Извлекает последнее сообщение пользователя из списка сообщений.

    Args:
        messages (Messages): Список словарей сообщений, каждый из которых содержит 'role' и 'content'.

    Returns:
        str: Последнее сообщение пользователя.
    """
    ...
```

**Назначение**: Извлекает последнее сообщение от пользователя из списка сообщений. Если есть несколько последовательных сообщений от пользователя, они объединяются в одну строку.

**Параметры**:
- `messages` (Messages): Список словарей, где каждый словарь представляет собой сообщение и содержит ключи `"role"` (роль отправителя) и `"content"` (содержимое сообщения).

**Возвращает**:
- `str`: Последнее сообщение от пользователя или пустая строка, если сообщений от пользователя нет.

**Как работает функция**:

1.  **Копирование списка сообщений**: Создается копия списка сообщений, чтобы не изменять исходный список.
2.  **Инициализация**: Инициализируется пустой список `user_messages` для хранения сообщений от пользователя и переменная `last_message` как последний элемент списка сообщений.
3.  **Перебор сообщений в обратном порядке**: Функция перебирает сообщения в обратном порядке, начиная с последнего.
4.  **Проверка роли сообщения**: Для каждого сообщения проверяется его роль (`"role"`). Если роль равна `"user"`, то содержимое сообщения добавляется в список `user_messages`.
5.  **Объединение сообщений пользователя**: Если встречается сообщение с ролью, отличной от `"user"`, функция объединяет все собранные сообщения пользователя в одну строку, разделяя их символом новой строки, и возвращает эту строку.
6.  **Обработка случая отсутствия сообщений не от пользователя**: Если все сообщения в списке от пользователя, функция также объединяет их в одну строку и возвращает.

```
Получение последнего сообщения пользователя
│
├── Копирование списка сообщений
│
├── Инициализация списка сообщений пользователя и переменной последнего сообщения
│
└── Перебор сообщений в обратном порядке
    │
    ├── Проверка роли сообщения
    │   │
    │   └── Если role="user": Добавление содержимого в список сообщений пользователя
    │   │
    │   └── Если role!="user": Объединение сообщений пользователя в строку и возврат
    │
    └── Если все сообщения от пользователя: Объединение сообщений в строку и возврат
```

**Примеры**:

```python
>>> messages = [{"role": "user", "content": "Hello"}, {"role": "assistant", "content": "Hi"}]
>>> get_last_user_message(messages)
'Hello'

>>> messages = [{"role": "user", "content": "Hello"}, {"role": "user", "content": "World"}]
>>> get_last_user_message(messages)
'Hello\nWorld'

>>> messages = [{"role": "assistant", "content": "Hi"}]
>>> get_last_user_message(messages)
''
```

### `format_image_prompt`

```python
def format_image_prompt(messages, prompt: str = None) -> str:
    """
    Форматирует промпт для генерации изображений, используя последнее сообщение пользователя или предоставленный промпт.

    Args:
        messages: Список сообщений.
        prompt (str, optional): Промпт для генерации изображений. Defaults to None.

    Returns:
        str: Сформированный промпт для генерации изображений.
    """
    ...
```

**Назначение**: Форматирует промпт для генерации изображений. Использует последнее сообщение пользователя, если не предоставлен явный промпт.

**Параметры**:
- `messages`: Список сообщений, содержащий историю общения.
- `prompt` (str, optional): Явный промпт для генерации изображений. Если не указан (`None`), используется последнее сообщение пользователя. По умолчанию `None`.

**Возвращает**:
- `str`: Сформированный промпт для генерации изображений.

**Как работает функция**:

1.  **Проверка наличия явного промпта**: Функция проверяет, был ли передан явный промпт (`prompt`).
2.  **Использование явного промпта**: Если явный промпт был передан (не `None`), функция возвращает его без изменений.
3.  **Получение последнего сообщения пользователя**: Если явный промпт не был передан, функция вызывает функцию `get_last_user_message(messages)` для получения последнего сообщения от пользователя.
4.  **Возврат промпта**: Функция возвращает полученный промпт (явный или последнее сообщение пользователя).

```
Форматирование промпта для изображений
│
├── Проверка наличия явного промпта
│   │
│   └── Если prompt is not None: Возврат prompt
│   │
│   └── Если prompt is None: Получение последнего сообщения пользователя
│       │
│       └── Возврат последнего сообщения пользователя
```

**Примеры**:

```python
>>> messages = [{"role": "user", "content": "Cat with sunglasses"}]
>>> format_image_prompt(messages)
'Cat with sunglasses'

>>> format_image_prompt(messages, prompt="Dog with a hat")
'Dog with a hat'
```

### `format_prompt_max_length`

```python
def format_prompt_max_length(messages: Messages, max_lenght: int) -> str:
    """
    Форматирует промпт, обрезая его до максимальной длины, если необходимо.

    Args:
        messages (Messages): Список сообщений.
        max_lenght (int): Максимальная длина промпта.

    Returns:
        str: Отформатированный и, возможно, обрезанный промпт.
    """
    ...
```

**Назначение**: Форматирует промпт из списка сообщений и обрезает его до указанной максимальной длины, если исходный промпт превышает эту длину. Использует различные стратегии обрезки, чтобы сохранить наиболее важные части промпта.

**Параметры**:
- `messages` (Messages): Список словарей, где каждый словарь представляет собой сообщение и содержит ключи `"role"` (роль отправителя) и `"content"` (содержимое сообщения).
- `max_lenght` (int): Максимальная длина промпта в символах.

**Возвращает**:
- `str`: Отформатированный промпт, обрезанный до максимальной длины, если необходимо.

**Как работает функция**:

1.  **Форматирование промпта**: Изначально форматирует все сообщения в один промпт с помощью функции `format_prompt(messages)`.
2.  **Проверка длины**: Проверяет, превышает ли длина полученного промпта (`prompt`) заданную максимальную длину (`max_lenght`).
3.  **Обрезка промпта (если необходимо)**: Если длина промпта превышает максимальную длину, функция пытается его обрезать, используя следующие стратегии:
    *   Если сообщений больше 6, оставляет только первые 3 и последние 3 сообщения и форматирует их.
    *   Если длина все еще превышает `max_lenght`, и сообщений больше 2, оставляет только системные сообщения и последнее сообщение пользователя.
    *   Если длина все еще превышает `max_lenght`, оставляет только содержимое последнего сообщения.
4.  **Логирование обрезки**: Если промпт был обрезан, функция логирует информацию об этом, указывая начальную и конечную длину промпта.

```
Форматирование и обрезка промпта
│
├── Форматирование всех сообщений в один промпт
│
├── Проверка длины промпта (превышает ли max_lenght)
│
└── Обрезка промпта (если необходимо)
    │
    ├── Если сообщений > 6: Оставляет только первые 3 и последние 3 сообщения
    │
    ├── Если длина все еще > max_lenght и сообщений > 2: Оставляет только системные сообщения и последнее сообщение пользователя
    │
    └── Если длина все еще > max_lenght: Оставляет только содержимое последнего сообщения
│
└── Логирование обрезки
│
└── Возврат отформатированного промпта
```

**Примеры**:

```python
>>> messages = [{"role": "user", "content": "This is a very long message"} for _ in range(10)]
>>> max_length = 50
>>> formatted_prompt = format_prompt_max_length(messages, max_length)
>>> len(formatted_prompt) <= max_length
True

>>> messages = [{"role": "user", "content": "Short message"}]
>>> max_length = 100
>>> formatted_prompt = format_prompt_max_length(messages, max_length)
>>> formatted_prompt
'User: Short message\nAssistant:'
```

### `get_random_string`

```python
def get_random_string(length: int = 10) -> str:
    """
    Генерирует случайную строку указанной длины, содержащую строчные буквы и цифры.

    Args:
        length (int, optional): Длина случайной строки для генерации. Defaults to 10.

    Returns:
        str: Случайная строка указанной длины.
    """
    ...
```

**Назначение**: Генерирует случайную строку заданной длины, состоящую из строчных букв и цифр.

**Параметры**:
- `length` (int, optional): Длина генерируемой случайной строки. По умолчанию равна 10.

**Возвращает**:
- `str`: Случайная строка указанной длины.

**Как работает функция**:

1.  **Выбор символов**: Функция использует строку `string.ascii_lowercase + string.digits`, содержащую все строчные буквы и цифры.
2.  **Генерация случайной строки**: Функция генерирует случайную строку, выбирая случайные символы из указанной строки `length` раз и объединяя их.

```
Генерация случайной строки
│
├── Определение набора символов (строчные буквы и цифры)
│
└── Генерация случайной строки путем выбора случайных символов из набора
│
└── Возврат случайной строки
```

**Примеры**:

```python
>>> get_random_string(5)
'a1b2c'

>>> len(get_random_string(20))
20
```

### `get_random_hex`

```python
def get_random_hex(length: int = 32) -> str:
    """
    Генерирует случайную шестнадцатеричную строку длиной n.

    Returns:
        str: Случайная шестнадцатеричная строка из n символов.
    """
    ...
```

**Назначение**: Генерирует случайную шестнадцатеричную строку заданной длины.

**Параметры**:
- `length` (int, optional): Длина генерируемой шестнадцатеричной строки. По умолчанию равна 32.

**Возвращает**:
- `str`: Шестнадцатеричная строка, состоящая из `length` случайных шестнадцатеричных символов.

**Как работает функция**:

1.  **Определение набора символов**: Функция использует строку `"abcdef" + string.digits`, содержащую все шестнадцатеричные символы (буквы `a` - `f` и цифры `0` - `9`).
2.  **Генерация шестнадцатеричной строки**: Функция генерирует случайную шестнадцатеричную строку, выбирая случайные символы из указанной строки `length` раз и объединяя их.

```
Генерация случайной шестнадцатеричной строки
│
├── Определение набора шестнадцатеричных символов (a-f и 0-9)
│
└── Генерация строки путем выбора случайных символов из набора
│
└── Возврат шестнадцатеричной строки
```

**Примеры**:

```python
>>> get_random_hex(5)
'a1b2c'

>>> len(get_random_hex(20))
20
```

### `filter_none`

```python
def filter_none(**kwargs) -> dict:
    """
    Фильтрует словарь, удаляя элементы со значением None.

    Returns:
        dict: Новый словарь, содержащий только элементы с не-None значениями.
    """
    ...
```

**Назначение**: Создает новый словарь, содержащий только те элементы из входного словаря, значения которых не равны `None`.

**Параметры**:
- `**kwargs`: Произвольное количество именованных аргументов, представляющих элементы словаря.

**Возвращает**:
- `dict`: Новый словарь, содержащий только элементы с не-`None` значениями.

**Как работает функция**:

1.  **Итерация по элементам словаря**: Функция проходит по всем элементам входного словаря, представленного в виде именованных аргументов `kwargs`.
2.  **Проверка значения**: Для каждого элемента проверяется, является ли его значение `None`.
3.  **Формирование нового словаря**: Если значение элемента не равно `None`, элемент добавляется в новый словарь.
4.  **Возврат нового словаря**: Функция возвращает новый словарь, содержащий только элементы с не-`None` значениями.

```
Фильтрация None значений
│
├── Итерация по элементам словаря
│
├── Проверка значения элемента (является ли None)
│
└── Формирование нового словаря с не-None значениями
│
└── Возврат нового словаря
```

**Примеры**:

```python
>>> filter_none(a=1, b=None, c="test")
{'a': 1, 'c': 'test'}

>>> filter_none(x=None, y=None)
{}
```

### `async_concat_chunks`

```python
async def async_concat_chunks(chunks: AsyncIterator) -> str:
    """
    Асинхронно объединяет чанки из асинхронного итератора в одну строку.

    Args:
        chunks (AsyncIterator): Асинхронный итератор, предоставляющий чанки.

    Returns:
        str: Объединенная строка из всех чанков.
    """
    ...
```

**Назначение**: Асинхронно объединяет чанки (фрагменты данных) из асинхронного итератора в одну строку.

**Параметры**:
- `chunks` (AsyncIterator): Асинхронный итератор, предоставляющий чанки данных.

**Возвращает**:
- `str`: Строка, представляющая собой конкатенацию всех чанков, полученных из итератора.

**Как работает функция**:

1.  **Преобразование асинхронного итератора в список**: Функция использует асинхронное включение списка `[chunk async for chunk in chunks]` для получения всех чанков из асинхронного итератора и сохранения их в списке.
2.  **Объединение чанков**: Функция вызывает функцию `concat_chunks` с полученным списком чанков для их объединения в одну строку.

```
Асинхронное объединение чанков
│
├── Преобразование асинхронного итератора в список чанков
│
└── Вызов функции concat_chunks для объединения чанков
│
└── Возврат объединенной строки
```

**Примеры**:

```python
# async def example_generator():
#     yield "chunk1"
#     yield "chunk2"
#
# async def main():
#     result = await async_concat_chunks(example_generator())
#     print(result)  # Вывод: chunk1chunk2
```

### `concat_chunks`

```python
def concat_chunks(chunks: Iterator) -> str:
    """
    Объединяет чанки из итератора в одну строку, исключая None и Exception.

    Args:
        chunks (Iterator): Итератор, предоставляющий чанки.

    Returns:
        str: Объединенная строка из всех чанков.
    """
    ...
```

**Назначение**: Объединяет чанки (фрагменты данных) из итератора в одну строку, исключая при этом элементы, которые являются `None` или экземплярами класса `Exception`.

**Параметры**:
- `chunks` (Iterator): Итератор, предоставляющий чанки данных.

**Возвращает**:
- `str`: Строка, представляющая собой конкатенацию всех чанков, полученных из итератора, за исключением `None` и `Exception`.

**Как работает функция**:

1.  **Преобразование чанков в строки**: Функция преобразует каждый чанк в строку с помощью `str(chunk)`.
2.  **Фильтрация чанков**: Функция фильтрует чанки, исключая те, которые равны `None` или являются экземплярами класса `Exception`.
3.  **Объединение чанков**: Функция объединяет отфильтрованные и преобразованные в строки чанки в одну строку с помощью метода `"".join()`.

```
Объединение чанков
│
├── Преобразование чанков в строки
│
├── Фильтрация чанков (исключение None и Exception)
│
└── Объединение чанков в строку
│
└── Возврат объединенной строки
```

**Примеры**:

```python
>>> concat_chunks(["chunk1", "chunk2", None, "chunk3"])
'chunk1chunk2chunk3'

>>> concat_chunks(["chunk1", Exception("error"), "chunk3"])
'chunk1chunk3'
```

### `format_cookies`

```python
def format_cookies(cookies: Cookies) -> str:
    """
    Форматирует словарь куки в строку для использования в HTTP-запросах.

    Args:
        cookies (Cookies): Словарь куки.

    Returns:
        str: Строка, представляющая куки в формате 'key=value; key=value; ...'.
    """
    ...
```

**Назначение**: Преобразует словарь с куками в строку, пригодную для использования в HTTP-запросах.

**Параметры**:
- `cookies` (Cookies): Словарь, где ключи - это имена кук, а значения - их значения.

**Возвращает**:
- `str`: Строка, представляющая куки в формате `'key=value; key=value; ...'`.

**Как работает функция**:

1.  **Форматирование каждой куки**: Функция проходит по всем элементам словаря `cookies` и для каждого элемента формирует строку в формате `"key=value"`.
2.  **Объединение кук**: Функция объединяет все отформатированные строки кук в одну строку, разделяя их символом `"; "`.

```
Форматирование куки
│
├── Форматирование каждой куки в строку "key=value"
│
└── Объединение кук в строку с разделителем "; "
│
└── Возврат строки кук
```

**Примеры**:

```python
>>> cookies = {"name": "value", "test": "123"}
>>> format_cookies(cookies)
'name=value; test=123'