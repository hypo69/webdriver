# Модуль для генерации таблиц в формате Markdown на основе данных о провайдерах и моделях g4f

## Обзор

Модуль предназначен для автоматического создания документации в формате Markdown, содержащей информацию о различных провайдерах и моделях, используемых в библиотеке `g4f` (GenerativeForFree). Он предоставляет функции для тестирования провайдеров, сбора данных о них и моделях, а также для форматирования этих данных в виде таблиц Markdown. Эти таблицы затем записываются в файл `docs/providers.md`.

## Подробней

Модуль выполняет следующие задачи:

1.  **Тестирование провайдеров**: Проверяет работоспособность доступных провайдеров, отправляя им тестовые запросы.
2.  **Сбор информации**: Собирает информацию о провайдерах, такую как их статус, поддержку потоковой передачи, системных сообщений, историю сообщений, а также список поддерживаемых моделей.
3.  **Форматирование данных**: Форматирует собранные данные в виде таблиц Markdown, удобных для чтения и включения в документацию.
4.  **Генерация документации**: Записывает сгенерированные таблицы в файл `docs/providers.md`, формируя часть документации проекта.

Этот модуль помогает поддерживать актуальную информацию о провайдерах и моделях, используемых в `g4f`, что важно для разработчиков и пользователей библиотеки.

## Функции

### `test_async`

```python
async def test_async(provider: ProviderType) -> bool:
    """
    Асинхронно проверяет работоспособность провайдера.

    Args:
        provider (ProviderType): Провайдер для тестирования.

    Returns:
        bool: `True`, если провайдер отвечает, иначе `False`.
    """
```

**Назначение**: Асинхронно проверяет работоспособность заданного провайдера. Отправляет тестовое сообщение и возвращает `True`, если получает ответ в течение заданного времени, иначе возвращает `False`.

**Параметры**:

*   `provider` (ProviderType): Провайдер, который необходимо протестировать.

**Возвращает**:

*   `bool`: `True`, если провайдер работает и отвечает на тестовое сообщение, иначе `False`.

**Как работает функция**:

1.  Проверяет, активен ли провайдер (`provider.working`). Если нет, сразу возвращает `False`.
2.  Формирует тестовое сообщение (`messages`).
3.  Асинхронно отправляет сообщение провайдеру с использованием `ChatCompletion.create_async`.
4.  Устанавливает таймаут ожидания ответа от провайдера (30 секунд) с использованием `asyncio.wait_for`.
5.  Если провайдер отвечает в течение таймаута, возвращает `True`.
6.  В случае возникновения исключения, логирует ошибку и возвращает `False`.

```
A[Проверка активности провайдера]
|
B[Формирование тестового сообщения]
|
C[Асинхронная отправка сообщения провайдеру и ожидание ответа с таймаутом]
|
D[Получен ответ?]
|
E[Да: Возврат True]    F[Нет: Логирование ошибки и возврат False]
```

**Примеры**:

```python
import asyncio
from g4f.providers import Bard

async def main():
    provider = Bard
    result = await test_async(provider)
    print(f"Provider {provider.__name__} is working: {result}")

asyncio.run(main())
```

### `test_async_list`

```python
def test_async_list(providers: list[ProviderType]) -> list:
    """
    Асинхронно тестирует список провайдеров.

    Args:
        providers (list[ProviderType]): Список провайдеров для тестирования.

    Returns:
        list: Список результатов тестирования для каждого провайдера.
    """
```

**Назначение**: Принимает список провайдеров и асинхронно тестирует каждый из них, возвращая список результатов.

**Параметры**:

*   `providers` (list[ProviderType]): Список провайдеров, которые необходимо протестировать.

**Возвращает**:

*   `list`: Список логических значений, где каждый элемент соответствует результату тестирования провайдера из входного списка.

**Как работает функция**:

1.  Использует генератор списков для асинхронного тестирования каждого провайдера из входного списка `providers` с использованием функции `test_async`.
2.  `asyncio.run` запускает каждую корутину `test_async` и дожидается ее завершения.
3.  Возвращает список результатов тестирования, где каждый элемент соответствует результату для соответствующего провайдера.

```
A[Получение списка провайдеров]
|
B[Запуск асинхронного тестирования для каждого провайдера]
|
C[Сбор результатов тестирования]
|
D[Возврат списка результатов]
```

**Примеры**:

```python
import asyncio
from g4f.providers import Bard, Ails

async def main():
    providers = [Bard, Ails]
    results = test_async_list(providers)
    for i, provider in enumerate(providers):
        print(f"Provider {provider.__name__} is working: {results[i]}")

asyncio.run(main())
```

### `print_providers`

```python
def print_providers() -> list[str]:
    """
    Формирует список строк с информацией о провайдерах для Markdown таблицы.

    Returns:
        list[str]: Список строк для Markdown таблицы.
    """
```

**Назначение**: Собирает информацию о доступных провайдерах и формирует строки для Markdown-таблицы, содержащей информацию о каждом провайдере.

**Возвращает**:

*   `list[str]`: Список строк, представляющих Markdown-таблицу с информацией о провайдерах.

**Как работает функция**:

1.  Получает список активных провайдеров из `__providers__`.
2.  Тестирует каждый провайдер с помощью `test_async_list` и получает список результатов.
3.  Разделяет провайдеров на две категории: "Free" (бесплатные) и "Auth" (требующие аутентификацию).
4.  Для каждой категории формирует заголовок Markdown.
5.  Для каждого провайдера формирует строки с информацией о его названии, веб-сайте, статусе, поддержке моделей, аутентификации, потоковой передачи, системных сообщений и истории сообщений.
6.  Использует `getattr(_provider, 'label', _provider.__name__)` для получения метки провайдера, если она определена, иначе использует имя провайдера.
7.  Форматирует URL веб-сайта провайдера, если он доступен.
8.  Форматирует информацию о поддержке различных функций провайдером (потоковая передача, системные сообщения, история сообщений) в виде символов "✔️" (поддерживается) и "❌" (не поддерживается).
9.  Формирует информацию о моделях, поддерживаемых провайдером, если провайдер является подклассом `ProviderModelMixin`.
10. Собирает все строки в список и возвращает его.

```
A[Получение списка активных провайдеров]
|
B[Тестирование провайдеров]
|
C[Разделение провайдеров на категории (Free/Auth)]
|
D[Для каждой категории:]
    |
    E[Формирование заголовка категории]
    |
    F[Для каждого провайдера в категории:]
        |
        G[Формирование строк с информацией о провайдере]
        |
        H[Добавление строк в общий список]
|
I[Возврат списка строк]
```

**Примеры**:

```python
lines = print_providers()
print("\n".join(lines))
```

### `print_models`

```python
def print_models() -> list[str]:
    """
    Формирует список строк с информацией о моделях для Markdown таблицы.

    Returns:
        list[str]: Список строк для Markdown таблицы.
    """
```

**Назначение**: Функция `print_models` создает список строк, предназначенных для формирования таблицы в формате Markdown. Эта таблица содержит информацию о различных моделях, включая их базового провайдера, конкретного провайдера и веб-сайт.

**Возвращает**:

*   `list[str]`: Список строк, которые можно объединить для создания Markdown таблицы с информацией о моделях.

**Как работает функция**:

1.  Определяет словари `base_provider_names` и `provider_urls`, содержащие имена и URL базовых провайдеров (Google, OpenAI, Huggingface и т.д.).
2.  Инициализирует список `lines` с заголовками таблицы Markdown: "Model", "Base Provider", "Provider", "Website".
3.  Перебирает модели из `models.ModelUtils.convert.items()`.
4.  Фильтрует модели, имена которых начинаются с "gpt-3.5" или "gpt-4", оставляя только "gpt-3.5-turbo", "gpt-4" и "gpt-4-turbo".
5.  Извлекает имя модели из `model.name`, используя регулярное выражение для разделения строки по символам ":" или "/".
6.  Проверяет, есть ли базовый провайдер модели в словаре `base_provider_names`. Если нет, пропускает модель.
7.  Определяет имя провайдера. Если `model.best_provider` является экземпляром `BaseRetryProvider`, то имя провайдера будет количеством провайдеров в `model.best_provider.providers` с добавлением "+ Providers". В противном случае имя провайдера берется из `model.best_provider.__name__` с префиксом "g4f.Provider.".
8.  Формирует URL веб-сайта провайдера из словаря `provider_urls`.
9.  Создает строку таблицы Markdown с информацией о модели, базовом провайдере, провайдере и веб-сайте.
10. Добавляет строку в список `lines`.
11. Возвращает список `lines`.

```
A[Определение словарей с именами и URL базовых провайдеров]
|
B[Инициализация списка с заголовками таблицы]
|
C[Перебор моделей]
|
D[Фильтрация моделей GPT]
|
E[Извлечение имени модели]
|
F[Проверка наличия базового провайдера в словаре]
|
G[Определение имени провайдера]
|
H[Формирование URL веб-сайта провайдера]
|
I[Создание строки таблицы Markdown с информацией о модели]
|
J[Добавление строки в список]
|
K[Возврат списка строк]
```

**Примеры**:

```python
lines = print_models()
print("\n".join(lines))
```

### `print_image_models`

```python
def print_image_models() -> list[str]:
    """
    Формирует список строк с информацией о моделях генерации и обработки изображений для Markdown таблицы.

    Returns:
        list[str]: Список строк для Markdown таблицы.
    """
```

**Назначение**: Функция `print_image_models` создает список строк, предназначенных для формирования таблицы в формате Markdown, которая содержит информацию о провайдерах, поддерживающих модели генерации и обработки изображений.

**Возвращает**:

*   `list[str]`: Список строк, которые можно объединить для создания Markdown таблицы с информацией о моделях изображений.

**Как работает функция**:

1.  Инициализирует список `lines` с заголовками таблицы Markdown: "Label", "Provider", "Image Model", "Vision Model", "Website".
2.  Перебирает провайдеров, которые активны (`provider.working`) и имеют атрибуты `image_models` или `vision_models`.
3.  Извлекает URL провайдера из атрибута `provider.url`. Если URL отсутствует, устанавливает значение "❌".
4.  Форматирует URL веб-сайта провайдера.
5.  Извлекает метку провайдера из атрибута `provider.label`, если он существует. В противном случае использует имя провайдера (`provider.__name__`).
6.  Формирует строку со списком моделей генерации изображений (`image_models`), если они поддерживаются провайдером. Если нет, устанавливает значение "❌".
7.  Проверяет, поддерживает ли провайдер модели обработки изображений (`vision_models`). Устанавливает значение "✔️", если поддерживаются, и "❌" в противном случае.
8.  Создает строку таблицы Markdown с информацией о провайдере, моделях генерации и обработки изображений, и веб-сайте.
9.  Добавляет строку в список `lines`.
10. Возвращает список `lines`.

```
A[Инициализация списка с заголовками таблицы]
|
B[Перебор провайдеров с поддержкой моделей изображений]
|
C[Извлечение URL провайдера]
|
D[Форматирование URL веб-сайта провайдера]
|
E[Извлечение метки провайдера]
|
F[Формирование строки со списком моделей генерации изображений]
|
G[Проверка поддержки моделей обработки изображений]
|
H[Создание строки таблицы Markdown с информацией о провайдере]
|
I[Добавление строки в список]
|
J[Возврат списка строк]
```

**Примеры**:

```python
lines = print_image_models()
print("\n".join(lines))
```

## Запуск модуля

```python
if __name__ == "__main__":
    with open("docs/providers.md", "w") as f:
        f.write("\\n".join(print_providers()))
        f.write(f"\\n{\'-\' * 50} \\n")
        #f.write("\\n".join(print_models()))
        #f.write(f"\\n{\'-\' * 50} \\n")
        f.write("\\n".join(print_image_models()))
```

**Назначение**: Данный блок кода выполняется только при непосредственном запуске скрипта. Он использует функции `print_providers` и `print_image_models` для создания содержимого документации и записывает его в файл `docs/providers.md`.

**Как работает**:

1.  Открывает файл `docs/providers.md` в режиме записи (`"w"`).
2.  Записывает в файл результат выполнения функции `print_providers`, который представляет собой Markdown-таблицу с информацией о провайдерах.
3.  Добавляет разделитель в виде строки из 50 символов `-`.
4.  Записывает в файл результат выполнения функции `print_image_models`, который представляет собой Markdown-таблицу с информацией о моделях обработки изображений.